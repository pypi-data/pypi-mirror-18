#!/usr/bin/env python

import argparse

parser = argparse.ArgumentParser(description="bit, [b]ermunda [i]nformation [t]riangle.\
 bit is a git-based tool for the management of code and data. It uses git for code versioning\
 and ownCloud for storing and exchanging data. It saves storage by avoiding versioning\
 of data while logging changes in associated git wikis.",\
formatter_class = argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("-i", "--input", nargs='*', help="Input files")
parser.add_argument("-s", "--subfolder", help="Subfolder to be created.", default=None)
parser.add_argument("-m", "--message",nargs='*', help="Message to write on log file.", default=None)
parser.add_argument("-d", "--pick_a_date", help="Pick an existing date folder to transfer data to/from. Format=YYYY-MM-DD", default=None)
parser.add_argument("-c", "--create_folder", help="Create dropbox folder for user to upload data.", action="store_true")
parser.add_argument("-g", "--getfolder", help="Downloads a folder as zip file. Requires --pick_a_date. Defaults --base_folder=upload:download to download", action="store_true")
parser.add_argument("-t", "--days_to_share", help="Number of days you wish to share this folder further.", default=21)
parser.add_argument("--scripts",help="Needs -i and -m. Simultaneously sync the scripts.user folder when uploading data.", action="store_true")
parser.add_argument("--start", help="Project name of the format. PI_PROJECT_NAME. Initiates a project. This will create the required local folders and respective git repositories.", default=None)
parser.add_argument("--stdfolders",nargs='*', help="Folders to be created in addition to scripts.user and and wiki.user when a project is started.", default=["tmp","slurm_logs"])
parser.add_argument("--adduser",help="Add a user to a project creating his scripts.user and wiki.user folder",action="store_true")
parser.add_argument("--sync", nargs='*',  help="Files or folders to syncronize with remote server using rsync over ssh.",default=None)
parser.add_argument("--sync_to", help="Destination server to sync to in the form: <user_name>@<server.address>", default=None)
parser.add_argument("--sync_from", help="Destination server to sync from in the form: <user_name>@<server.address>", default=None)
parser.add_argument("--forceRemote", help="If syncing from or to a remoter server force the import of a remote 'bit_config'.", action="store_true")
parser.add_argument("--gitssh", help="Use your git SSH keys.",  action="store_true")
parser.add_argument("--config", help="Generate a config file.", action="store_true")
args = parser.parse_args()

import json
import time
import datetime
import owncloud
import os
import sys
import getpass
from os.path import expanduser
from subprocess import Popen, PIPE, STDOUT
import subprocess as sb
import stat
import tempfile
import pwd


structure="\n\
/file_system_a\n\
    |\n\
    '- data\n\
        |\n\
        '- projects\n\
            |\n\
            |- Company_A\n\
            |   |\n\
            |   |- CA_project_y\n\
            |   |\n\
            |   '- CA_project_x\n\
            |       |\n\
            |       |- results\n\
            |       |- models\n\
            |       |- scripts\n\
            |       |- tmp\n\
            |       |- slurm_logs\n\
            |       '- wiki\n\
            |\n\
            '- Company_B\n\
                |\n\
                '- CB_project_n\n\n\
absolute path to projects =  /file_system_a/data/projects/"

def get_owncloud_address():
    owncloud_address=str(raw_input("Please give in your ownCloud address (eg. http://domain.tld/owncloud): ")) or None
    return owncloud_address

def get_owncloud_upload_folder():
    owncloud_upload_folder=str(raw_input("Please give in the folder in your ownCloud that will be used to deliver data to users.\nYou can share this folder with your colleagues so that everybody delivers data through the same folder. (default: DELIVERY_SERVICE):")) or "DELIVERY_SERVICE"
    return owncloud_upload_folder

def get_owncloud_download_folder():
    owncloud_download_folder=str(raw_input("Please give in the folder in your ownCloud that will be used to retrieve data from users.\nYou can share this folder with your colleagues so that everybody retrieves data through the same folder. (default: DROPBOX):")) or "DROPBOX"
    return owncloud_download_folder

def get_owncloud_user(config_file=None):
    if config_file:
        owncloud_user=str(raw_input("Please give in your ownCloud user name or press Enter if you do not want to save this information on the config file: ")) or None
    else:
        owncloud_user=str(raw_input("Please give in your ownCloud user name: ")) or None
    return owncloud_user

def get_owncloud_pass(config_file=None):
    if config_file:
        owncloud_pass=str(getpass.getpass(prompt="Please give in your ownCloud password or press Enter if you do not want to save this information on the config file: ")) or None
    else:
        owncloud_pass=str(getpass.getpass(prompt="Please give in your ownCloud password: ")) or None
    return owncloud_pass

def get_github_address():
    github_address=str(raw_input("Github server address (default: https://github.com): ") or "https://github.com")
    return github_address

def get_github_organization():
    github_organization=str(raw_input("Your GitHub organization name (eg. mpg-age-bioinformatics for https://github.com/mpg-age-bioinformatics): ")) or None
    return github_organization

def get_github_user(config_file=None,gitssh=args.gitssh):
    if not gitssh:
        if config_file:
            github_user=str(raw_input("Please give in your user name for your github server or press Enter if you do not want to save this information on the config file: ")) or None
        else:
            github_user=str(raw_input("Please give in your user name for your github server: ")) or None
    else:
        github_user=None
    return github_user

def get_github_pass(config_file=None,gitssh=args.gitssh):
    if not gitssh:
        if config_file:
            github_pass=str(getpass.getpass(prompt="Please give in your password for your github server or press Enter if you do not want to save this information on the config file: ")) or None
        else:
            github_pass=str(getpass.getpass(prompt="Please give in your password for your github server: ")) or None
    else:
        github_pass=None
    return github_pass

def get_local_path(structure=structure):
    local_path=str(raw_input("The bermuda information triangle works on the basis that all your projects are located in the same path and have a parent subpath in your local machine ie. %s\n" %structure ) ) or None
    return local_path

def get_user_group():
    user_group=str(raw_input("If you are using ACLs to give your group members access to this project please give in the users that will have read write access to every projects top folders. eg. userA,userB,userC: ")) or None
    if user_group:
        user_group=user_group.split(",")
	return user_group

def get_github_api(github_address):
    if "github.com" in github_address:
        github_api="https://api.github.com/orgs/"
    else:
        github_api=github_address+"/api/v3/orgs/"
    return github_api

def check_reqs(requirements,configdic,config_file=None, gitssh=args.gitssh):
    if "owncloud_address" in requirements:
        configdic["owncloud_address"]=get_owncloud_address()
    if "owncloud_upload_folder" in requirements:
        configdic["owncloud_upload_folder"]=get_owncloud_upload_folder()
    if "owncloud_download_folder" in requirements:
        configdic["owncloud_download_folder"]=get_owncloud_download_folder()
    if "owncloud_user" in requirements:
        configdic["owncloud_user"]=get_owncloud_user(config_file=config_file)
    if "owncloud_pass" in requirements:
        configdic["owncloud_pass"]=get_owncloud_pass(config_file=config_file)
    if "github_address" in requirements:
        configdic["github_address"]=get_github_address()
    if "github_organization" in requirements:
        configdic["github_organization"]=get_github_organization()
    if "github_user" in requirements:
        configdic["github_user"]=get_github_user(config_file=config_file,gitssh=gitssh )
    if "github_pass" in requirements:
        configdic["github_pass"]=get_github_pass(config_file=config_file,gitssh=gitssh )
    if "local_path" in requirements:
        configdic["local_path"]=get_local_path()
    if "user_group" in requirements:
        configdic["user_group"]=get_user_group()
    return configdic

requirements=["owncloud_address","owncloud_upload_folder",\
"owncloud_download_folder","owncloud_user",\
"owncloud_pass","github_address",\
"github_organization","github_user",\
"github_pass","local_path", "user_group" ]

special_reqs=["owncloud_user","owncloud_pass",\
"github_user","github_pass"]

start_reqs=["github_address","github_organization",\
"github_user","github_pass","local_path","user_group" ]


def git_target(github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh,usepw=None):
    url=github_address.split("//")[-1]
    if not args.gitssh:
        git="https://%s:%s@%s/%s/%s.git" %(github_user,github_pass,url,github_organization,github_repo)
    else:
        git="git@%s:%s/%s.git" %(url,github_organization,github_repo)
    if usepw:
        git2="https://%s@%s/%s/%s.git" %(github_user,url,github_organization,github_repo)
        return git, git2
    else:
        return git

def git_clone(local_name,github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    git, git2 =git_target(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh,usepw=True)
    if not os.path.exists(local_name):
        os.makedirs(local_name)
    cwd = os.getcwd()
    os.chdir(local_name)
    out=sb.call(['git','init'])
    out=sb.call(['git','config','remote.origin.url',git2])
    out=sb.call(['git','config','branch.master.remote','origin'])
    out=sb.call(['git','config','branch.master.merge','refs/heads/master'])
    out=sb.call(['git','pull', git])
    os.chdir(cwd)
    return out

def git_fetch(github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    git=git_target(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh)
    call=["git","fetch",git]
    out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    print out.communicate()[0].rstrip()

def git_merge(message):
    call=["git","merge","FETCH_HEAD","-m",message]
    out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    print out.communicate()[0].rstrip()

def git_pull(github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    git=git_target(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh)
    call=["git","pull",git]
    out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    print out.communicate()[0].rstrip()

def git_add(files_to_add):
    for f in files_to_add:
        call=["git","add",f]
        out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
        print out.communicate()[0].rstrip()

def git_commit(message):
    call=["git","commit","-m", message]
    out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    print out.communicate()[0].rstrip()

def git_push(github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    git=git_target(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh)
    call=["git","push",git,"--all"]
    if gitssh:
        out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
        print out.communicate()[0].rstrip()
    else:
        FNULL = open(os.devnull, 'w')
        out=Popen(call, stdout=FNULL, stdin=PIPE ,stderr=STDOUT) #, stdout=FNULL, stderr=subprocess.STDOUT old: stdout=PIPE, stdin=PIPE, stderr=STDOUT
        out=Popen(["git","push"],stdout=PIPE, stdin=PIPE, stderr=STDOUT)

def git_sync(files_to_add,message,github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    git_add(files_to_add)
    git_commit(message)
    git_fetch(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh)
    git_merge(message)
    git_push(github_address,github_organization,github_repo,github_user=github_user,github_pass=github_pass,gitssh=gitssh)

def make_bitconfig(require_func=requirements,special_reqs=special_reqs):
    configdic={}
    configdic=check_reqs(require_func,configdic,config_file=True, gitssh=None)
    uhome=expanduser("~")+"/"
    configfile=open(uhome+".bit_config","w+")
    with open(uhome+".bit_config", 'w') as configfile:
        json.dump(configdic, configfile)
    os.chmod(uhome+".bit_config", stat.S_IRWXU )
    print "Your bit config file as been generated:"
    for c in configdic:
        if "pass" not in c:
            print c, configdic.get(c)
            sys.stdout.flush()
        elif configdic.get(c) == None:
            print c, configdic.get(c)
            sys.stdout.flush()
        else:
            print c, "*"
            sys.stdout.flush()

def read_bitconfig(showit=None,bit_config=".bit_config"):
    uhome=expanduser("~")+"/"
    with open(uhome+bit_config, 'r') as configfile:
        configdic=json.load(configfile)
    if showit:
        for c in configdic:
            if "pass" not in c:
                print c, configdic.get(c)
                sys.stdout.flush()
            elif configdic.get(c) == None:
                print c, configdic.get(c)
                sys.stdout.flush()
            else:
                print c, "*"
                sys.stdout.flush()
    return configdic

def init_user(path_to_project,github_address,github_organization,github_repo,github_user=None,github_pass=None,gitssh=args.gitssh):
    user_name=getpass.getuser()
    response=git_clone(path_to_project+"/scripts."+user_name , github_address, github_organization, github_repo, github_user=github_user, github_pass=github_pass, gitssh=gitssh)
    response=git_clone(path_to_project+"/wiki."+user_name , github_address, github_organization, github_repo+".wiki", github_user=github_user, github_pass=github_pass, gitssh=gitssh)
    while response == 1:
        raw_input("\n\n*************\n\nThe wiki for this project has not yet been created.\n\n Please go to %s/%s/%s/wiki and click on 'Create the first page' and then 'Save Page'.\n\nPress Enter once you have saved the first wiki page.\n\n*************\n\n" %(github_address,github_organization,github_repo) )
        response=git_clone(path_to_project+"/wiki."+user_name ,github_address,github_organization,github_repo+".wiki",github_user=github_user,github_pass=github_pass,gitssh=gitssh)

def list_upload(base_destination,list_of_files):
    upload_dic={}
    subfolders=[base_destination]
    check=base_destination.split("/")
    for i in range(len(check)):
        c="/".join(check[:i-len(check)])
        subfolders.append(c)

    for f in list_of_files:
        full=os.path.abspath(f)
        if os.path.isdir(full):
            subfol=base_destination+"/"+os.path.basename(full)
            subfolders.append(subfol)
            for root, directories, filenames in os.walk(full):
                bad_dirs=[]
                for directory in directories:
                    if os.path.basename(directory)[0] != ".":
                        subdir=os.path.join(root, directory).split(full)[-1]
                        subdir=subfol+subdir
                        subfolders.append(subdir)
                    else:
                        bad_dirs.append(os.path.basename(directory))
                for filename in filenames:
                    if not any(x in filename for x in bad_dirs):
                        subfile=os.path.join(root,filename)
                        if os.path.isfile(subfile):
                            upload_dic[subfile]=subfol+subfile.split(full)[-1]

        elif os.path.isfile(full):
            upload_dic[full]=base_destination+"/"+os.path.basename(full)

    subfolders=list(set(subfolders))
    subfolders=[ xx for xx in subfolders if len(xx) > 0 ]
    subfolders.sort()

    return upload_dic, subfolders

def get_ownCloud_links(link_info,http):
    link_info=str(link_info)
    store=link_info.split("path=")[1].split(",")[0]
    store=store.split("/")
    store="%2F".join(store)
    link=link_info.split("link=")[1].split(",")[0]
    print "\nYour link:\n%s" %http+"/index.php/apps/files?dir="+store
    print "Public link:\n%s\n" %link
    return http+"/index.php/apps/files?dir="+store

def get_owncloud_base_folder(configdic,project_name):

    if args.getfolder:
        if not args.pick_a_date:
            print "--getfolder implies --pick_a_date.\nPlease use -d in \
            combination with -g.\nThank you!"
            sys.exit()
        else:
            base_folder=configdic["owncloud_download_folder"]
    elif args.create_folder:
        base_folder=configdic["owncloud_download_folder"]
    else:
        base_folder=configdic["owncloud_upload_folder"]

    if args.pick_a_date == None:
        d = str(datetime.date.today())
    else:
        d = str(args.pick_a_date)

    if args.subfolder:
        d = d+"/"+str(args.subfolder)

    base_destination=base_folder+"/"+project_name+"/"+d

    return base_destination

def ownCloud_upload(input_files=args.input,message=args.message):

    if type(message) == list:
        message=[ str(xx) for xx in message ]
        message=" ".join(message)
    else:
        message=str(message)

    configdic=read_bitconfig()
    for r in requirements:
        if not args.gitssh:
            if r not in ["user_group" ]:
                while configdic[r] == None:
                    configdic=check_reqs([r],configdic,config_file=None, \
                    gitssh=None)
        else:
            if r not in [ "github_user", "github_pass","user_group" ]:
                while configdic[r] == None:
                    configdic=check_reqs([r],configdic,config_file=None, \
                    gitssh=args.gitssh)

    local_path=os.path.abspath(configdic["local_path"])

    # check if files all come from the same project folder
    size_local=len(local_path.split("/"))
    parent_folder=[]
    check_project=[]
    for i in input_files:
        f=os.path.abspath(i)
        parent_folder.append(f.split("/")[size_local])
        check_project.append(f.split("/")[size_local+1])
    check_project=list(set(check_project))
    if len(check_project) > 1:
        print "Found more than one project:\n"
        for p in check_project:
            print p
            sys.stdout.flush()
        sys.exit(0)
    else:
        project_name=check_project[0]
        parent_folder=parent_folder[0]

    target_project=parent_folder+"/"+project_name

    base_destination=get_owncloud_base_folder(configdic,target_project)

    upload_dic, subfolders=list_upload(base_destination,input_files)

    # login to owncloud
    try:
        oc=owncloud.Client(configdic["owncloud_address"])
        oc.login(configdic["owncloud_user"],configdic["owncloud_pass"])
    except:
        print "Could not login to ownCloud.\nPlease make sure you are giving \
        the right address to your owncloud and using the right login credentials."
        sys.exit(0)

    # create required subfolders in ownCloud
    for fold in subfolders:
        try:
            oc.file_info(fold)
        except:
            oc.mkdir(fold)

    # Upload files
    if len(upload_dic)>1:
        print "Uploading %s files.." %str(len(upload_dic))
        sys.stdout.flush()
    else:
        print "Uploading %s file.." %str(len(upload_dic))
        sys.stdout.flush()

    skipped_files=[]
    for f in upload_dic:
        file_handle = open(f, 'r', 8192)
        file_handle.seek(0, os.SEEK_END)
        size = file_handle.tell()
        file_handle.seek(0)
        if size == 0:
            skipped_files.append(os.path.basename(f))
            print "\t%s is empty. Skipping .. " %str(f)
            sys.stdout.flush()
            continue
        if size > 1879048192:
            print "\t%s\t(chunked)" %str(upload_dic[f])
            sys.stdout.flush()
            oc.put_file(upload_dic[f],f)
        else:
            print "\t%s" %str(upload_dic[f])
            sys.stdout.flush()
            oc.put_file(upload_dic[f],f,chunked=False)

    print "Finished uploading."
    # Time stamp for expiration date
    tshare = datetime.date.today()
    tshare = tshare + datetime.timedelta(days=int(args.days_to_share))
    tshare = time.mktime(tshare.timetuple())

    link_info = oc.share_file_with_link(base_destination,expiration=tshare)
    private_link=get_ownCloud_links(link_info,configdic["owncloud_address"])

    oc.logout()

    # Go to wiki folder and make a git sync
    print "Logging changes.."
    sys.stdout.flush()
    user_name=getpass.getuser()
    os.chdir(local_path+"/"+target_project+"/wiki."+user_name)
    files_to_add=os.listdir(local_path+"/"+target_project+"/wiki."+user_name)
    git_sync(files_to_add,"bit sync",configdic["github_address"],\
    configdic["github_organization"],project_name+".wiki",\
    github_user=configdic["github_user"],github_pass=configdic["github_pass"],\
    gitssh=args.gitssh)

    # Write log file
    if len(skipped_files) > 0:
        skipped_files=", ".join(skipped_files)
        skipped_files="\n\n(skipped: %s)" %skipped_files
    else:
        skipped_files=""
    logfile="uploads.md"
    logtext="\n\n#####["+base_destination.split("/")[3]+"\t::\t"+user_name+"]\
    ("+private_link+") : "+str(" ".join(args.message))+"\n"+\
    str(datetime.datetime.now()).split(".")[0]+", "+str(", ".join(input_files))\
    +skipped_files

    log=open(logfile,"a")
    log.write(logtext)
    log.close()

    #  push the log
    git_add(["uploads.md"])
    git_commit(message)
    git_push(configdic["github_address"],configdic["github_organization"],\
    project_name+".wiki",github_user=configdic["github_user"],\
    github_pass=configdic["github_pass"],gitssh=args.gitssh)

    if args.scripts:
        print "Syncronizing your code.."
        sys.stdout.flush()
        os.chdir(local_path+"/"+target_project+"/scripts."+user_name)
        files_to_add=os.listdir(local_path+"/"+target_project+"/scripts."+user_name)
        git_sync(files_to_add,message,configdic["github_address"],\
        configdic["github_organization"],project_name,\
        github_user=configdic["github_user"],\
        github_pass=configdic["github_pass"],gitssh=args.gitssh)

downloadreqs=["owncloud_address","owncloud_upload_folder",\
"owncloud_download_folder","owncloud_user",\
"owncloud_pass","local_path"]

def ownCloud_download():
    configdic=read_bitconfig()
    for r in downloadreqs:
        while configdic[r] == None:
            configdic=check_reqs([r],configdic,config_file=None, \
            gitssh=args.gitssh)
    local_path=os.path.abspath(configdic["local_path"])

    size_local=len(local_path.split("/"))

    f=os.path.abspath(str(args.pick_a_date))
    parent_folder=f.split("/")[size_local]
    project_name=f.split("/")[size_local+1]

    target_project=parent_folder+"/"+project_name

    base_destination=get_owncloud_base_folder(configdic,target_project)

    # login to owncloud
    try:
        oc=owncloud.Client(configdic["owncloud_address"] )
        oc.login(configdic["owncloud_user"],configdic["owncloud_pass"])
    except:
        print "Could not login to ownCloud.\nPlease make sure you are giving \
        the right address to your owncloud and using the right login credentials."
        sys.exit(0)

    oc.get_directory_as_zip(base_destination, args.pick_a_date+".zip")
    oc.logout()
    print "Downloaded %s.zip" %args.pick_a_date
    sys.stdout.flush()

def ownCloud_create_folder():
    configdic=read_bitconfig()
    for r in downloadreqs:
        while configdic[r] == None:
            configdic=check_reqs([r],configdic,config_file=None, \
            gitssh=args.gitssh)
    local_path=os.path.abspath(configdic["local_path"])

    size_local=len(local_path.split("/"))

    f=os.path.abspath(str(args.pick_a_date))
    parent_folder=f.split("/")[size_local]
    project_name=f.split("/")[size_local+1]

    target_project=parent_folder+"/"+project_name

    base_destination=get_owncloud_base_folder(configdic,target_project)

    # login to owncloud
    try:
        oc=owncloud.Client(configdic["owncloud_address"] )
        oc.login(configdic["owncloud_user"],configdic["owncloud_pass"])
    except:
        print "Could not login to ownCloud.\nPlease make sure you are giving \
        the right address to your owncloud and using the right login credentials."
        sys.exit(0)

    check=base_destination.split("/")
    print check
    for i in range(len(check)+1):
        c="/".join(check[:i])
        print c
        try:
            oc.file_info(c)
        except:
            oc.mkdir(c)

    # Time stamp for expiration date
    tshare = datetime.date.today()
    tshare = tshare + datetime.timedelta(days=int(args.days_to_share))
    tshare = time.mktime(tshare.timetuple())

    link_info = oc.share_file_with_link(base_destination,expiration=tshare)
    private_link=get_ownCloud_links(link_info,configdic["owncloud_address"])

    oc.logout()

def get_remote_config(sshLogin,remotePass):
    remote_address=sshLogin.split("@")[1]
    call="sshpass -p "+remotePass+" scp "+sshLogin+":~/.bit_config \
    ~/.bit_config."+remote_address
    os.system(call)
    uhome=expanduser("~")+"/"
    if os.path.isfile(uhome+".bit_config.%s" %remote_address) :
        os.chmod(uhome+".bit_config.%s" %remote_address, stat.S_IRWXU )
    else:
        print "Could not find ~/.bit_config on remote server.\nPlease run \
        'bit --config' on remote server."
        sys.exit(0)

def read_remote_config(sshLogin,remotePass,forceImport=None):
    remote_address=sshLogin.split("@")[1]
    if os.path.isfile(".bit_config.%s" %remote_address):
        if not forceImport:
            print "Using previously collected remote config."
        else:
            get_remote_config(sshLogin,remotePass)
    else:
        get_remote_config(sshLogin,remotePass)

    remote_config=read_bitconfig(showit=None,bit_config=".bit_config.%s" \
    %remote_address)
    return remote_config

def list_local_sync(base_destination,list_of_files):

    # check if files all come from the same project folder
    configdic=read_bitconfig()
    local_path=configdic["local_path"]
    size_local=len(local_path.split("/"))
    parent_folder=[]
    check_project=[]
    for i in list_of_files:
        f=os.path.abspath(i)
        parent_folder.append(f.split("/")[size_local])
        check_project.append(f.split("/")[size_local+1])
    check_project=list(set(check_project))
    if len(check_project) > 1:
        print "Found more than one project:\n"
        for p in check_project:
            print p
            sys.stdout.flush()
        sys.exit(0)
    else:
        project_name=check_project[0]
        parent_folder=parent_folder[0]

    target_project=parent_folder+"/"+project_name

    base_destination=base_destination+parent_folder+"/"+project_name
    upload_dic={}
    subfolders=[base_destination]
    check=base_destination.split("/")
    for i in range(len(check)):
        c="/".join(check[:i-len(check)])
        subfolders.append(c)

    for f in list_of_files:
        full=os.path.abspath(f)
        if os.path.isdir(full):
            subfol=base_destination+"/"+os.path.basename(full)
            subfolders.append(subfol)
            for root, directories, filenames in os.walk(full):
                bad_dirs=[]
                for directory in directories:
                    if os.path.basename(directory)[0] != ".":
                        subdir=os.path.join(root, directory).split(full)[-1]
                        subdir=subfol+subdir
                        subfolders.append(subdir)
                    else:
                        bad_dirs.append(os.path.basename(directory))
                for filename in filenames:
                    if not any(x in filename for x in bad_dirs):
                        subfile=os.path.join(root,filename)
                        if os.path.isfile(subfile):
                            upload_dic[subfile]=subfol+subfile.split(full)[-1]

        elif os.path.isfile(full):
            upload_dic[full]=base_destination+"/"+os.path.basename(full)
        else:
            upload_dic[full]=base_destination+"/"+os.path.basename(full)

    subfolders=list(set(subfolders))
    subfolders=[ xx for xx in subfolders if len(xx) > 0 ]
    subfolders.sort()

    return upload_dic, subfolders, base_destination, parent_folder

def list_local_for_remote_sync(base_destination,list_of_files):

    # check if files all come from the same project folder
    configdic=read_bitconfig()
    local_path=configdic["local_path"]
    size_local=len(local_path.split("/"))
    parent_folder=[]
    check_project=[]
    for i in list_of_files:
        f=os.path.abspath(i)
        parent_folder.append(f.split("/")[size_local])
        check_project.append(f.split("/")[size_local+1])
    check_project=list(set(check_project))
    if len(check_project) > 1:
        print "Found more than one project:\n"
        for p in check_project:
            print p
            sys.stdout.flush()
        sys.exit(0)
    else:
        project_name=check_project[0]
        parent_folder=parent_folder[0]

    target_project=parent_folder+"/"+project_name

    base_destination=base_destination+parent_folder+"/"+project_name
    upload_dic={}
    subfolders=[base_destination]
    check=base_destination.split("/")
    for i in range(len(check)):
        c="/".join(check[:i-len(check)])
        subfolders.append(c)

    for f in list_of_files:
        full=os.path.abspath(f)
        if os.path.isdir(full):
            subfol=base_destination+"/"+os.path.basename(full)
            upload_dic[full]=base_destination+"/"+os.path.basename(full)
            subfolders.append(subfol)
        elif os.path.isfile(full):
            upload_dic[full]=base_destination+"/"+os.path.basename(full)
        else:
            upload_dic[full]=base_destination+"/"+os.path.basename(full)

    subfolders=list(set(subfolders))
    subfolders=[ xx for xx in subfolders if len(xx) > 0 ]
    subfolders.sort()

    return upload_dic, subfolders, base_destination, parent_folder


def rsync_to(sshLogin,rsync_files,forceImport=None,sync_to=True,sync_from=False):
    remotePass=str(getpass.getpass(prompt="Please give in your password for %s:\
     " %sshLogin.split("@")[1] ))

    remote_config=read_remote_config(sshLogin,remotePass,forceImport)
    remote_path=remote_config["local_path"]
    sync_dic, subfolders, path_to_project, parent_folder=list_local_sync(remote_path,\
    rsync_files)

    create_subfolders=[ ff for ff in subfolders if ff not in remote_path ]
    create_subfolders=" ".join(create_subfolders)
    print create_subfolders

    if remote_config["user_group"]:
        remote_group=" ".join(remote_config["user_group"])
        remote_group_group="; chmod 700 "+remote_path+parent_folder+" ; for us in "\
        +remote_group+" ; do setfacl -m user:$us:rwx "+remote_path+parent_folder+"; done "

        remote_group_project="; chmod 700 "+path_to_project+" ; for us in "\
        +remote_group+" ; do setfacl -m user:$us:rwx "+path_to_project+" "
    else:
        remote_group_group="; echo Not_using_acls "
        remote_group_project="; echo Not_using_acls "

    create_subfolders="\'MANAGER=$(ls -ld "+remote_path+" | awk \"{ print \\$3 }\" ); \
    if [ ! -d "+remote_path+parent_folder+" ]; then mkdir -p "+remote_path+\
    parent_folder+remote_group_group+"; chown $MANAGER "+remote_path+parent_folder+"; fi; \
    if [ ! -d "+path_to_project+" ]; then mkdir -p "+path_to_project+remote_group_project+"; chown \
    $MANAGER "+path_to_project+"; fi; \
    for f in "+create_subfolders+"; do if [ ! -d $f ]; then mkdir -p $f; fi; done\'"

    create_subfolders="sshpass -p "+str(remotePass)+" ssh "+str(sshLogin)+" "+create_subfolders
    os.system(create_subfolders)

    for f in sync_dic:
        call='rsync -tlzhP --rsh="sshpass -p %s ssh -o \
        StrictHostKeyChecking=no -l %s" %s %s:%s' %(str(remotePass), \
        str(sshLogin.split("@")[0]), f,  str(sshLogin.split("@")[1]), \
        sync_dic[f])
        os.system(call)

def rsync_from(sshLogin,rsync_files,forceImport=None,sync_to=False,sync_from=True):
    remotePass=str(getpass.getpass(prompt="Please give in your password for %s: "\
    %sshLogin.split("@")[1] ))

    configdic=read_bitconfig()
    local_path=configdic["local_path"]

    remote_config=read_remote_config(sshLogin,remotePass,forceImport)
    remote_path=remote_config["local_path"]

    # get remote dirs and subdirs

    sync_dic, subfolders, path_to_project, parent_folder=list_local_for_remote_sync(\
    remote_path, rsync_files)

    check_remote=[]
    for f in sync_dic:
         check_remote.append(sync_dic[f])
    check_remote=" ".join(check_remote)

    # check if files exist on remote
    temp=tempfile.NamedTemporaryFile()
    check_remote_files="\'for f in "+check_remote+" ; do if [ -f $f ]; then echo $f; fi; done\' > "+temp.name
    check_remote_files="sshpass -p "+str(remotePass)+" ssh "+str(sshLogin)+" "+check_remote_files
    os.system(check_remote_files)
    res=temp.readlines()
    temp.close()
    resFiles=[ s.strip("\n") for s in res ]

    # check if folders exist on remote
    temp=tempfile.NamedTemporaryFile()
    check_remote_folder="\'for f in "+check_remote+" ; do if [ -d $f ]; then echo $f; find $f -type d -print; fi; done\' > "+temp.name
    check_remote_folder="sshpass -p "+str(remotePass)+" ssh "+str(sshLogin)+" "+check_remote_folder
    os.system(check_remote_folder)
    res=temp.readlines()
    temp.close()
    resFolders=[ s.strip("\n")+"/" for s in res ]

    list_folders_contents=" ".join(resFolders)
    temp=tempfile.NamedTemporaryFile()
    check_remote_folder="\'for f in "+list_folders_contents+" ; do cd $f;\
    for c in $(ls); do cc=$(readlink -f $c); if [ -f $cc ]; then echo $cc; fi; done; done\' > "+temp.name
    check_remote_folder="sshpass -p "+str(remotePass)+" ssh "+str(sshLogin)+" "+check_remote_folder
    os.system(check_remote_folder)
    res=temp.readlines()
    temp.close()
    resAllFiles=[ s.strip("\n") for s in res ]

    res=[resFiles, resAllFiles] #resFolders
    res=[item for sublist in res for item in sublist]
    res=list(set(res))

    showres="\n".join(res)
    print "The following targets could be found on the remote server:\n%s" %showres
    sys.stdout.flush()

    inv_sync_dic={}
    for r in res:
        inv_sync_dic[r]=local_path+"/"+r.split(remote_path)[1]

    lenLocalPath=len(os.path.abspath(local_path).split("/"))
    for remfold in resFolders:
        ltf=local_path+"/"+remfold.split(remote_path)[1]
        if not os.path.exists(ltf):
            os.makedirs(ltf)
            if len(os.path.abspath(ltf).split("/")) in [lenLocalPath+1,lenLocalPath+2]:
                if configdic["user_group"]:
                    os.chmod(ltf, stat.S_IRWXU)
                    user_group=configdic["user_group"]
                    try:
                        for use in user_group:
                            call=["setfacl","-m","user:%s:rwx" %use,ltf]
                            out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
                            print out.communicate()[0].rstrip()

                    except:
                        print "Failed to setfacls."
                        sys.stdout.flush()
                local_path_owner=os.stat(local_path)
                local_path_owner=local_path_owner.st_uid
                os.chown(ltf,local_path_owner,-1)

    for f in inv_sync_dic:
        call='rsync -tlzhP --rsh="sshpass -p %s ssh -o \
        StrictHostKeyChecking=no -l %s" %s:%s %s' %(str(remotePass), \
        str(sshLogin.split("@")[0]), str(sshLogin.split("@")[1]), \
        f, inv_sync_dic[f] )
        os.system(call)

if args.sync:
    if args.sync_to:
        rsync_to(args.sync_to, args.sync, forceImport=args.forceRemote, \
        sync_to=True, sync_from=False)
    elif args.sync_from:
        rsync_from(args.sync_from, args.sync, forceImport=args.forceRemote, \
        sync_to=False, sync_from=True)


if args.config:
    print "Setting up your config file."
    sys.stdout.flush()
    make_bitconfig()
    sys.exit(0)

# initate a project
if args.start:
    configdic=read_bitconfig()
    for r in start_reqs:
        if r != "user_group":
            while configdic[r] == None:
                configdic=check_reqs([r],configdic,config_file=None, gitssh=None)
    local_path=os.path.abspath(configdic["local_path"])
    full_path=os.path.abspath(args.start)
    project_name=os.path.basename(full_path)

    # check format projects_folder/group_head/project_name
    checkf=len(local_path.split("/"))
    if len(full_path.split("/")) != len(local_path.split("/"))+2:
        print "The path (%s) to this project does not obey the structure \
        and/or defined local path (%s). Check the reference structure:\n%s" \
        %(full_path,local_path,structure)
        sys.stdout.flush()
        sys.exit(0)

    # have the user rechecking that the the string for the project name is really correct
    checks=None
    while checks not in ["Y","N"]:
        checks=str(raw_input("Is the label %s in agreement with the structure \
        PF_project_name where PF stands for the initials of the Parent_Folder? \
        (Y/N) " %project_name )) or None
    if checks=="N":
        sys.exit(0)

    # create the repo
    github_api=get_github_api(configdic["github_address"])
    github_api=github_api+configdic["github_organization"]+"/repos"
    create_call=["curl","-u",configdic["github_user"]+":"+configdic["github_pass"]\
    ,github_api,"-d",'{"name":"'+project_name+'","private": "true",\
    "auto_init": true }']

    p = Popen(create_call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
    print p.communicate()[0].rstrip()
    sys.stdout.flush()

    # clone the repo and the wiki by initiating this user
    raw_input("\n\n*************\n\nPlease go to %s/%s/%s/wiki and click on \
    'Create the first page' and then 'Save Page'.\n\nPress Enter once you have \
    saved the first wiki page.\n\n*************\n\n" \
    %(configdic["github_address"],configdic["github_organization"],project_name) )

    init_user(full_path,configdic["github_address"],configdic["github_organization"],\
    project_name,github_user=configdic["github_user"],\
    github_pass=configdic["github_pass"],gitssh=args.gitssh)

    # create additional folders
    for f in args.stdfolders:
        if not os.path.exists(full_path+"/"+f):
            os.makedirs(full_path+"/"+f)

    if configdic["user_group"]:
        os.chmod(full_path, stat.S_IRWXU)
        user_group=configdic["user_group"]
        try:
            for use in user_group:
                call=["setfacl","-m","user:%s:rwx" %use,full_path]
                out=Popen(call, stdout=PIPE, stdin=PIPE, stderr=STDOUT)
                print out.communicate()[0].rstrip()
        except:
            print "Failed to setfacls."
            sys.stdout.flush()

    local_path_owner=os.stat(local_path)
    local_path_owner=local_path_owner.st_uid
    os.chown(full_path,local_path_owner,-1)

    sys.exit(0)

if args.adduser:
    configdic=read_bitconfig()
    for r in start_reqs:
        while configdic[r] == None:
            configdic=check_reqs([r],configdic,config_file=None, gitssh=args.gitssh)
    local_path=os.path.abspath(configdic["local_path"])
    if args.start:
        full_path=os.path.abspath(args.start)
    else:
        full_path=os.path.abspath(os.getcwd())
    project_name=os.path.basename(full_path)

    # check format projects_folder/group_head/project_name
    checkf=len(local_path.split("/"))
    if len(full_path.split("/")) != len(local_path.split("/"))+2:
        print "The path (%s) to this project does not obey the structure and/or defined local path (%s). Check the reference structure:\n%s" %(full_path,local_path,structure)
        sys.stdout.flush()
        sys.exit(0)

    init_user(full_path,configdic["github_address"],configdic["github_organization"],project_name,github_user=configdic["github_user"],github_pass=configdic["github_pass"],gitssh=args.gitssh)
    sys.exit(0)

if args.input:
    if not args.message:
        print "ERROR\nYou need to use -m to leave a message in the logs."
        sys.exit()
    ownCloud_upload()
    sys.exit(0)

if args.create_folder:
    ownCloud_create_folder()
    sys.exit(0)

if args.getfolder:
    if args.pick_a_date == None:
        print "--getfolder implies --pick_a_date.\nPlease use -d in combination with -g.\nThank you!"
        sys.exit(0)
    ownCloud_download()
    sys.exit(0)

sys.exit(0)
