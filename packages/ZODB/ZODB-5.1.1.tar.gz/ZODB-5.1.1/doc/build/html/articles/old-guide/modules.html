<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Related Modules &#8212; ZODB  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/zodb.ico"/>
    <link rel="top" title="ZODB  documentation" href="../../index.html" />
    <link rel="up" title="Very old ZODB programming guide" href="index.html" />
    <link rel="next" title="Resources" href="links.html" />
    <link rel="prev" title="Transactions and Versioning" href="transactions.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="related-modules">
<h1>Related Modules<a class="headerlink" href="#related-modules" title="Permalink to this headline">¶</a></h1>
<p>The ZODB package includes a number of related modules that provide useful data
types such as BTrees.</p>
<div class="section" id="persistent-mapping-persistentmapping">
<h2><code class="xref py py-mod docutils literal"><span class="pre">persistent.mapping.PersistentMapping</span></code><a class="headerlink" href="#persistent-mapping-persistentmapping" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#PersistentMapping" title="PersistentMapping"><code class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></code></a> class is a wrapper for mapping objects that will
set the dirty bit when the mapping is modified by setting or deleting a key.</p>
<dl class="function">
<dt id="PersistentMapping">
<code class="descname">PersistentMapping</code><span class="sig-paren">(</span><em>container = {}</em><span class="sig-paren">)</span><a class="headerlink" href="#PersistentMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#PersistentMapping" title="PersistentMapping"><code class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></code></a> object that wraps the mapping object
<em>container</em>.  If you don&#8217;t specify a value for <em>container</em>, a regular Python
dictionary is used.</p>
</dd></dl>

<p><a class="reference internal" href="#PersistentMapping" title="PersistentMapping"><code class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></code></a> objects support all the same methods as Python
dictionaries do.</p>
</div>
<div class="section" id="persistent-list-persistentlist">
<h2><code class="xref py py-mod docutils literal"><span class="pre">persistent.list.PersistentList</span></code><a class="headerlink" href="#persistent-list-persistentlist" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#PersistentList" title="PersistentList"><code class="xref py py-class docutils literal"><span class="pre">PersistentList</span></code></a> class is a wrapper for mutable sequence objects,
much as <a class="reference internal" href="#PersistentMapping" title="PersistentMapping"><code class="xref py py-class docutils literal"><span class="pre">PersistentMapping</span></code></a> is a wrapper for mappings.</p>
<dl class="function">
<dt id="PersistentList">
<code class="descname">PersistentList</code><span class="sig-paren">(</span><em>initlist = []</em><span class="sig-paren">)</span><a class="headerlink" href="#PersistentList" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#PersistentList" title="PersistentList"><code class="xref py py-class docutils literal"><span class="pre">PersistentList</span></code></a> object that wraps the mutable sequence object
<em>initlist</em>.  If you don&#8217;t specify a value for <em>initlist</em>, a regular Python list
is used.</p>
</dd></dl>

<p><a class="reference internal" href="#PersistentList" title="PersistentList"><code class="xref py py-class docutils literal"><span class="pre">PersistentList</span></code></a> objects support all the same methods as Python lists do.</p>
</div>
<div class="section" id="btrees-package">
<h2>BTrees Package<a class="headerlink" href="#btrees-package" title="Permalink to this headline">¶</a></h2>
<p>When programming with the ZODB, Python dictionaries aren&#8217;t always what you need.
The most important case is where you want to store a very large mapping.  When a
Python dictionary is accessed in a ZODB, the whole dictionary has to be
unpickled and brought into memory.  If you&#8217;re storing something very large, such
as a 100,000-entry user database, unpickling such a large object will be slow.
BTrees are a balanced tree data structure that behave like a mapping but
distribute keys throughout a number of tree nodes.  The nodes are stored in
sorted order (this has important consequences &#8211; see below).  Nodes are then
only unpickled and brought into memory as they&#8217;re accessed, so the entire tree
doesn&#8217;t have to occupy memory (unless you really are touching every single key).</p>
<p>The BTrees package provides a large collection of related data structures.
There are variants of the data structures specialized to integers, which are
faster and use less memory.  There are five modules that handle the different
variants.  The first two letters of the module name specify the types of the
keys and values in mappings &#8211; O for any object, I for 32-bit signed integer,
and (new in ZODB 3.4) F for 32-bit C float.  For example, the
<code class="xref py py-mod docutils literal"><span class="pre">BTrees.IOBTree</span></code> module provides a mapping with integer keys and arbitrary
objects as values.</p>
<p>The four data structures provide by each module are a BTree, a Bucket, a
TreeSet, and a Set.  The BTree and Bucket types are mappings and support all the
usual mapping methods, e.g. <code class="xref py py-func docutils literal"><span class="pre">update()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">keys()</span></code>.  The TreeSet and
Set types are similar to mappings but they have no values; they support the
methods that make sense for a mapping with no keys, e.g. <code class="xref py py-func docutils literal"><span class="pre">keys()</span></code> but not
<code class="xref py py-func docutils literal"><span class="pre">items()</span></code>.  The Bucket and Set types are the individual building blocks for
BTrees and TreeSets, respectively.  A Bucket or Set can be used when you are
sure that it will have few elements.  If the data structure will grow large, you
should use a BTree or TreeSet. Like Python lists, Buckets and Sets are allocated
in one contiguous piece, and insertions and deletions can take time proportional
to the number of existing elements.  Also like Python lists, a Bucket or Set is
a single object, and is pickled and unpickled in its entirety.  BTrees and
TreeSets are multi-level tree structures with much better (logarithmic) worst-
case time bounds, and the tree structure is built out of multiple objects, which
ZODB can load individually as needed.</p>
<p>The five modules are named <code class="xref py py-mod docutils literal"><span class="pre">OOBTree</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">IOBTree</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">OIBTree</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">IIBTree</span></code>, and (new in ZODB 3.4) <code class="xref py py-mod docutils literal"><span class="pre">IFBTree</span></code>.  The two letter prefixes
are repeated in the data types names.  The <code class="xref py py-mod docutils literal"><span class="pre">BTrees.OOBTree</span></code> module defines
the following types: <code class="xref py py-class docutils literal"><span class="pre">OOBTree</span></code>, <code class="xref py py-class docutils literal"><span class="pre">OOBucket</span></code>, <code class="xref py py-class docutils literal"><span class="pre">OOSet</span></code>, and
<code class="xref py py-class docutils literal"><span class="pre">OOTreeSet</span></code>. Similarly, the other four modules each define their own
variants of those four types.</p>
<p>The <code class="xref py py-func docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">values()</span></code>, and <code class="xref py py-func docutils literal"><span class="pre">items()</span></code> methods on BTree and TreeSet
types do not materialize a list with all of the data.  Instead, they return lazy
sequences that fetch data from the BTree as needed.  They also support optional
arguments to specify the minimum and maximum values to return, often called
&#8220;range searching&#8221;.  Because all these types are stored in sorted order, range
searching is very efficient.</p>
<p>The <code class="xref py py-func docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">values()</span></code>, and <code class="xref py py-func docutils literal"><span class="pre">items()</span></code> methods on Bucket and Set
types do return lists with all the data. Starting in ZODB 3.3, there are also
<code class="xref py py-func docutils literal"><span class="pre">iterkeys()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">itervalues()</span></code>, and <code class="xref py py-func docutils literal"><span class="pre">iteritems()</span></code> methods that return
iterators (in the Python 2.2 sense).  Those methods also apply to BTree and
TreeSet objects.</p>
<p>A BTree object supports all the methods you would expect of a mapping, with a
few extensions that exploit the fact that the keys are sorted. The example below
demonstrates how some of the methods work.  The extra methods are <code class="xref py py-func docutils literal"><span class="pre">minKey()</span></code>
and <code class="xref py py-func docutils literal"><span class="pre">maxKey()</span></code>, which find the minimum and maximum key value subject to an
optional bound argument, and <code class="xref py py-func docutils literal"><span class="pre">byValue()</span></code>, which should probably be ignored
(it&#8217;s hard to explain exactly what it does, and as a result it&#8217;s almost never
used &#8211; best to consider it deprecated).  The various methods for enumerating
keys, values and items also accept minimum and maximum key arguments (&#8220;range
search&#8221;), and (new in ZODB 3.3) optional Boolean arguments to control whether a
range search is inclusive or exclusive of the range&#8217;s endpoints.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.OOBTree</span> <span class="k">import</span> <span class="n">OOBTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">OOBTree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;spades&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;green&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1"># this is a &quot;lazy&quot; sequence object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;OOBTreeItems object at 0x0088AD20&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># it acts like a Python list</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># materialize the full list</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># values at keys in 1 to 2 inclusive</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>    <span class="c1"># values at keys &gt;= 2</span>
<span class="go">[&#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>  <span class="c1"># keyword args new in ZODB 3.3</span>
<span class="go">[&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;spades&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">excludemin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">excludemax</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;green&#39;, &#39;blue&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">minKey</span><span class="p">()</span>     <span class="c1"># smallest key</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">minKey</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>  <span class="c1"># smallest key &gt;= 1.5</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">k</span><span class="p">,</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>    <span class="c1"># new in ZODB 3.3</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">k</span><span class="p">,</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>  <span class="c1"># new in ZODB 3.3</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">pair</span><span class="p">,</span>
<span class="gp">...</span>
<span class="go">(1, &#39;red&#39;) (2, &#39;green&#39;) (3, &#39;blue&#39;) (4, &#39;spades&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># returns a true value, but exactly what undefined</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">t</span>  <span class="c1"># new in ZODB 3.3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="ow">in</span> <span class="n">t</span>  <span class="c1"># new in ZODB 3.3</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Each of the modules also defines some functions that operate on BTrees &#8211;
<code class="xref py py-func docutils literal"><span class="pre">difference()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">union()</span></code>, and <code class="xref py py-func docutils literal"><span class="pre">intersection()</span></code>.  The
<code class="xref py py-func docutils literal"><span class="pre">difference()</span></code> function returns a Bucket, while the other two methods return
a Set. If the keys are integers, then the module also defines
<code class="xref py py-func docutils literal"><span class="pre">multiunion()</span></code>.  If the values are integers or floats, then the module also
defines <code class="xref py py-func docutils literal"><span class="pre">weightedIntersection()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">weightedUnion()</span></code>.  The function
doc strings describe each function briefly.</p>
<p><code class="docutils literal"><span class="pre">BTrees/Interfaces.py</span></code> defines the operations, and is the official
documentation.  Note that the interfaces don&#8217;t define the concrete types
returned by most operations, and you shouldn&#8217;t rely on the concrete types that
happen to be returned:  stick to operations guaranteed by the interface.  In
particular, note that the interfaces don&#8217;t specify anything about comparison
behavior, and so nothing about it is guaranteed.  In ZODB 3.3, for example, two
BTrees happen to use Python&#8217;s default object comparison, which amounts to
comparing the (arbitrary but fixed) memory addresses of the BTrees. This may or
may not be true in future releases. If the interfaces don&#8217;t specify a behavior,
then whether that behavior appears to work, and exactly happens if it does
appear to work, are undefined and should not be relied on.</p>
<div class="section" id="total-ordering-and-persistence">
<h3>Total Ordering and Persistence<a class="headerlink" href="#total-ordering-and-persistence" title="Permalink to this headline">¶</a></h3>
<p>The BTree-based data structures differ from Python dicts in several fundamental
ways.  One of the most important is that while dicts require that keys support
hash codes and equality comparison, the BTree-based structures don&#8217;t use hash
codes and require a total ordering on keys.</p>
<p>Total ordering means three things:</p>
<ol class="arabic simple">
<li>Reflexive.  For each <em>x</em>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> is true.</li>
<li>Trichotomy.  For each <em>x</em> and <em>y</em>, exactly one of <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>, and
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> is true.</li>
<li>Transitivity.  Whenever <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> and <code class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, it&#8217;s also true that <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span>
<span class="pre">z</span></code>.</li>
</ol>
<p>The default comparison functions for most objects that come with Python satisfy
these rules, with some crucial cautions explained later.  Complex numbers are an
example of an object whose default comparison function does not satisfy these
rules:  complex numbers only support <code class="docutils literal"><span class="pre">==</span></code> and <code class="docutils literal"><span class="pre">!=</span></code> comparisons, and raise an
exception if you try to compare them in any other way.  They don&#8217;t satisfy the
trichotomy rule, and must not be used as keys in BTree-based data structures
(although note that complex numbers can be used as keys in Python dicts, which
do not require a total ordering).</p>
<p>Examples of objects that are wholly safe to use as keys in BTree-based
structures include ints, longs, floats, 8-bit strings, Unicode strings, and
tuples composed (possibly recursively) of objects of wholly safe types.</p>
<p>It&#8217;s important to realize that even if two types satisfy the rules on their own,
mixing objects of those types may not.  For example, 8-bit strings and Unicode
strings both supply total orderings, but mixing the two loses trichotomy; e.g.,
<code class="docutils literal"><span class="pre">'x'</span> <span class="pre">&lt;</span> <span class="pre">chr(255)</span></code> and <code class="docutils literal"><span class="pre">u'x'</span> <span class="pre">==</span> <span class="pre">'x'</span></code>, but trying to compare <code class="docutils literal"><span class="pre">chr(255)</span></code> to
<code class="docutils literal"><span class="pre">u'x'</span></code> raises an exception.  Partly for this reason (another is given later),
it can be dangerous to use keys with multiple types in a single BTree-based
structure.  Don&#8217;t try to do that, and you don&#8217;t have to worry about it.</p>
<p>Another potential problem is mutability:  when a key is inserted in a BTree-
based structure, it must retain the same order relative to the other keys over
time.  This is easy to run afoul of if you use mutable objects as keys.  For
example, lists supply a total ordering, and then</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">,</span> <span class="n">L3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.OOBTree</span> <span class="k">import</span> <span class="n">OOSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">OOSet</span><span class="p">((</span><span class="n">L2</span><span class="p">,</span> <span class="n">L3</span><span class="p">,</span> <span class="n">L1</span><span class="p">))</span>  <span class="c1"># this is fine, so far</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>           <span class="c1"># note that the lists are in sorted order</span>
<span class="go">[[1], [2], [3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">has_key</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>           <span class="c1"># and [3] is in the set</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>                <span class="c1"># horrible -- the set is insane now</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">has_key</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>           <span class="c1"># for example, it&#39;s insane this way</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">OOSet([[1], [5], [3]])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Key lookup relies on that the keys remain in sorted order (an efficient form of
binary search is used).  By mutating key L2 after inserting it, we destroyed the
invariant that the OOSet is sorted.  As a result, all future operations on this
set are unpredictable.</p>
<p>A subtler variant of this problem arises due to persistence:  by default, Python
does several kinds of comparison by comparing the memory addresses of two
objects.  Because Python never moves an object in memory, this does supply a
usable (albeit arbitrary) total ordering across the life of a program run (an
object&#8217;s memory address doesn&#8217;t change).  But if objects compared in this way
are used as keys of a BTree-based structure that&#8217;s stored in a database, when
the objects are loaded from the database again they will almost certainly wind
up at different memory addresses.  There&#8217;s no guarantee then that if key K1 had
a memory address smaller than the memory address of key K2 at the time K1 and K2
were inserted in a BTree, K1&#8217;s address will also be smaller than K2&#8217;s when that
BTree is loaded from a database later.  The result will be an insane BTree,
where various operations do and don&#8217;t work as expected, seemingly at random.</p>
<p>Now each of the types identified above as &#8220;wholly safe to use&#8221; never compares
two instances of that type by memory address, so there&#8217;s nothing to worry about
here if you use keys of those types.  The most common mistake is to use keys
that are instances of a user-defined class that doesn&#8217;t supply its own
<code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> method.  Python compares such instances by memory address.  This
is fine if such instances are used as keys in temporary BTree-based structures
used only in a single program run.  It can be disastrous if that BTree-based
structure is stored to a database, though.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">(),</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>   <span class="c1"># this may print 0 if you try it</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">(),</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>   <span class="c1"># and this may print 0 or 1</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>That example illustrates that comparison of instances of classes that don&#8217;t
define <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> yields arbitrary results (but consistent results within a
single program run).</p>
<p>Another problem occurs with instances of classes that do define <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code>,
but define it incorrectly.  It&#8217;s possible but rare for a custom <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code>
implementation to violate one of the three required formal properties directly.
It&#8217;s more common for it to &#8220;fall back&#8221; to address-based comparison by mistake.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mine</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">is</span> <span class="n">Mine</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s quite possible there that the <code class="docutils literal"><span class="pre">else</span></code> clause allows a result to be
computed based on memory address.  The bug won&#8217;t show up until a BTree-based
structure uses objects of class <code class="xref py py-class docutils literal"><span class="pre">Mine</span></code> as keys, and also objects of other
types as keys, and the structure is loaded from a database, and a sequence of
comparisons happens to execute the <code class="docutils literal"><span class="pre">else</span></code> clause in a case where the
relative order of object memory addresses happened to change.</p>
<p>This is as difficult to track down as it sounds, so best to stay far away from
the possibility.</p>
<p>You&#8217;ll stay out of trouble by follwing these rules, violating them only with
great care:</p>
<ol class="arabic">
<li><p class="first">Use objects of simple immutable types as keys in BTree-based data structures.</p>
</li>
<li><p class="first">Within a single BTree-based data structure, use objects of a single type as
keys.  Don&#8217;t use multiple key types in a single structure.</p>
</li>
<li><p class="first">If you want to use class instances as keys, and there&#8217;s any possibility that
the structure may be stored in a database, it&#8217;s crucial that the class define a
<code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> method, and that the method is carefully implemented.</p>
<p>Any part of a comparison implementation that relies (explicitly or implicitly)
on an address-based comparison result will eventually cause serious failure.</p>
</li>
<li><p class="first">Do not use <code class="xref py py-class docutils literal"><span class="pre">Persistent</span></code> objects as keys, or objects of a subclass of
<code class="xref py py-class docutils literal"><span class="pre">Persistent</span></code>.</p>
</li>
</ol>
<p>That last item may be surprising.  It stems from details of how conflict
resolution is implemented:  the states passed to conflict resolution do not
materialize persistent subobjects (if a persistent object P is a key in a BTree,
then P is a subobject of the bucket containing P).  Instead, if an object O
references a persistent subobject P directly, and O is involved in a conflict,
the states passed to conflict resolution contain an instance of an internal
<code class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></code> stub class everywhere O references P. Two
<code class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></code> instances compare equal if and only if they
&#8220;represent&#8221; the same persistent object; when they&#8217;re not equal, they compare by
memory address, and, as explained before, memory-based comparison must never
happen in a sane persistent BTree.  Note that it doesn&#8217;t help in this case if
your <code class="xref py py-class docutils literal"><span class="pre">Persistent</span></code> subclass defines a sane <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> method:
conflict resolution doesn&#8217;t know about your class, and so also doesn&#8217;t know
about its <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> method.  It only sees instances of the internal
<code class="xref py py-class docutils literal"><span class="pre">PersistentReference</span></code> stub class.</p>
</div>
<div class="section" id="iteration-and-mutation">
<h3>Iteration and Mutation<a class="headerlink" href="#iteration-and-mutation" title="Permalink to this headline">¶</a></h3>
<p>As with a Python dictionary or list, you should not mutate a BTree-based data
structure while iterating over it, except that it&#8217;s fine to replace the value
associated with an existing key while iterating.  You won&#8217;t create internal
damage in the structure if you try to remove, or add new keys, while iterating,
but the results are undefined and unpredictable.  A weak attempt is made to
raise <code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code> if the size of a BTree-based structure changes while
iterating, but it doesn&#8217;t catch most such cases, and is also unreliable.
Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.IIBTree</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">IISet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>  <span class="c1"># the output is undefined</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">0 2 4 6 8</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">RuntimeError</span>: <span class="n">the bucket being iterated changed size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="c1"># this output is also undefined</span>
<span class="go">[1, 3, 5, 7, 9]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Also as with Python dictionaries and lists, the safe and predictable way to
mutate a BTree-based structure while iterating over it is to iterate over a copy
of the keys.  Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">BTrees.IIBTree</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">IISet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>  <span class="c1"># this is well defined</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">i</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">0 1 2 3 4 5 6 7 8 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="btree-diagnostic-tools">
<h3>BTree Diagnostic Tools<a class="headerlink" href="#btree-diagnostic-tools" title="Permalink to this headline">¶</a></h3>
<p>A BTree (or TreeSet) is a complex data structure, really a graph of variable-
size nodes, connected in multiple ways via three distinct kinds of C pointers.
There are some tools available to help check internal consistency of a BTree as
a whole.</p>
<p>Most generally useful is the <code class="xref py py-mod docutils literal"><span class="pre">BTrees.check</span></code> module.  The
<code class="xref py py-func docutils literal"><span class="pre">check.check()</span></code> function examines a BTree (or Bucket, Set, or TreeSet) for
value-based consistency, such as that the keys are in strictly increasing order.
See the function docstring for details. The <code class="xref py py-func docutils literal"><span class="pre">check.display()</span></code> function
displays the internal structure of a BTree.</p>
<p>BTrees and TreeSets also have a <code class="xref py py-meth docutils literal"><span class="pre">_check()</span></code> method.  This verifies that the
(possibly many) internal pointers in a BTree or TreeSet are mutually consistent,
and raises <code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> if they&#8217;re not.</p>
<p>If a <code class="xref py py-func docutils literal"><span class="pre">check.check()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">_check()</span></code> call fails, it may point to a bug in
the implementation of BTrees or conflict resolution, or may point to database
corruption.</p>
<p>Repairing a damaged BTree is usually best done by making a copy of it. For
example, if <em>self.data</em> is bound to a corrupted IOBTree,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">IOBTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>usually suffices.  If object identity needs to be preserved,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">acopy</span> <span class="o">=</span> <span class="n">IOBTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">acopy</span><span class="p">)</span>
</pre></div>
</div>
<p>does the same, but leaves <em>self.data</em> bound to the same object.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/zodb.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Related Modules</a><ul>
<li><a class="reference internal" href="#persistent-mapping-persistentmapping"><code class="docutils literal"><span class="pre">persistent.mapping.PersistentMapping</span></code></a></li>
<li><a class="reference internal" href="#persistent-list-persistentlist"><code class="docutils literal"><span class="pre">persistent.list.PersistentList</span></code></a></li>
<li><a class="reference internal" href="#btrees-package">BTrees Package</a><ul>
<li><a class="reference internal" href="#total-ordering-and-persistence">Total Ordering and Persistence</a></li>
<li><a class="reference internal" href="#iteration-and-mutation">Iteration and Mutation</a></li>
<li><a class="reference internal" href="#btree-diagnostic-tools">BTree Diagnostic Tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">ZODB articles</a><ul>
  <li><a href="index.html">Very old ZODB programming guide</a><ul>
      <li>Previous: <a href="transactions.html" title="previous chapter">Transactions and Versioning</a></li>
      <li>Next: <a href="links.html" title="next chapter">Resources</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/articles/old-guide/modules.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2016, Zope Foundation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="../../_sources/articles/old-guide/modules.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>