<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Transactions and Versioning &#8212; ZODB  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/zodb.ico"/>
    <link rel="top" title="ZODB  documentation" href="../../index.html" />
    <link rel="up" title="Very old ZODB programming guide" href="index.html" />
    <link rel="next" title="Related Modules" href="modules.html" />
    <link rel="prev" title="ZEO" href="zeo.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="transactions-and-versioning">
<h1>Transactions and Versioning<a class="headerlink" href="#transactions-and-versioning" title="Permalink to this headline">¶</a></h1>
<div class="section" id="committing-and-aborting">
<h2>Committing and Aborting<a class="headerlink" href="#committing-and-aborting" title="Permalink to this headline">¶</a></h2>
<p>Changes made during a transaction don&#8217;t appear in the database until the
transaction commits.  This is done by calling the <code class="xref py py-meth docutils literal"><span class="pre">commit()</span></code> method of the
current <code class="xref py py-class docutils literal"><span class="pre">Transaction</span></code> object, where the latter is obtained from the
<code class="xref py py-meth docutils literal"><span class="pre">get()</span></code> method of the current transaction manager.  If the default thread
transaction manager is being used, then <code class="docutils literal"><span class="pre">transaction.commit()</span></code> suffices.</p>
<p>Similarly, a transaction can be explicitly aborted (all changes within the
transaction thrown away) by invoking the <code class="xref py py-meth docutils literal"><span class="pre">abort()</span></code> method of the current
<code class="xref py py-class docutils literal"><span class="pre">Transaction</span></code> object, or simply <code class="docutils literal"><span class="pre">transaction.abort()</span></code> if using the
default thread transaction manager.</p>
<p>Prior to ZODB 3.3, if a commit failed (meaning the <code class="docutils literal"><span class="pre">commit()</span></code> call raised an
exception), the transaction was implicitly aborted and a new transaction was
implicitly started.  This could be very surprising if the exception was
suppressed, and especially if the failing commit was one in a sequence of
subtransaction commits.</p>
<p>So, starting with ZODB 3.3, if a commit fails, all further attempts to commit,
join, or register with the transaction raise
<code class="xref py py-exc docutils literal"><span class="pre">ZODB.POSException.TransactionFailedError</span></code>.  You must explicitly start a
new transaction then, either by calling the <code class="xref py py-meth docutils literal"><span class="pre">abort()</span></code> method of the current
transaction, or by calling the <code class="xref py py-meth docutils literal"><span class="pre">begin()</span></code> method of the current transaction&#8217;s
transaction manager.</p>
</div>
<div class="section" id="subtransactions">
<h2>Subtransactions<a class="headerlink" href="#subtransactions" title="Permalink to this headline">¶</a></h2>
<p>Subtransactions can be created within a transaction.  Each subtransaction can be
individually committed and aborted, but the changes within a subtransaction are
not truly committed until the containing transaction is committed.</p>
<p>The primary purpose of subtransactions is to decrease the memory usage of
transactions that touch a very large number of objects.  Consider a transaction
during which 200,000 objects are modified.  All the objects that are modified in
a single transaction have to remain in memory until the transaction is
committed, because the ZODB can&#8217;t discard them from the object cache.  This can
potentially make the memory usage quite large.  With subtransactions, a commit
can be be performed at intervals, say, every 10,000 objects.  Those 10,000
objects are then written to permanent storage and can be purged from the cache
to free more space.</p>
<p>To commit a subtransaction instead of a full transaction, pass a true value to
the <code class="xref py py-meth docutils literal"><span class="pre">commit()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">abort()</span></code> method of the <code class="xref py py-class docutils literal"><span class="pre">Transaction</span></code> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Commit a subtransaction</span>
<span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Abort a subtransaction</span>
<span class="n">transaction</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>A new subtransaction is automatically started upon successful committing or
aborting the previous subtransaction.</p>
</div>
<div class="section" id="undoing-changes">
<h2>Undoing Changes<a class="headerlink" href="#undoing-changes" title="Permalink to this headline">¶</a></h2>
<p>Some types of <code class="xref py py-class docutils literal"><span class="pre">Storage</span></code> support undoing a transaction even after it&#8217;s
been committed.  You can tell if this is the case by calling the
<code class="xref py py-meth docutils literal"><span class="pre">supportsUndo()</span></code> method of the <a class="reference internal" href="../../reference/zodb.html#DB" title="DB"><code class="xref py py-class docutils literal"><span class="pre">DB</span></code></a> instance, which returns true if
the underlying storage supports undo.  Alternatively you can call the
<code class="xref py py-meth docutils literal"><span class="pre">supportsUndo()</span></code> method on the underlying storage instance.</p>
<p>If a database supports undo, then the <code class="xref py py-meth docutils literal"><span class="pre">undoLog(start,</span> <span class="pre">end[,</span> <span class="pre">func])()</span></code> method
on the <a class="reference internal" href="../../reference/zodb.html#DB" title="DB"><code class="xref py py-class docutils literal"><span class="pre">DB</span></code></a> instance returns the log of past transactions, returning
transactions between the times <em>start</em> and <em>end</em>, measured in seconds from the
epoch. If present, <em>func</em> is a function that acts as a filter on the
transactions to be returned; it&#8217;s passed a dictionary representing each
transaction, and only transactions for which <em>func</em> returns true will be
included in the list of transactions returned to the caller of <code class="xref py py-meth docutils literal"><span class="pre">undoLog()</span></code>.
The dictionary contains keys for various properties of the transaction.  The
most important keys are <code class="docutils literal"><span class="pre">id</span></code>, for the transaction ID, and <code class="docutils literal"><span class="pre">time</span></code>, for the
time at which the transaction was committed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">storage</span><span class="o">.</span><span class="n">undoLog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span><span class="p">)</span>
<span class="go">[{&#39;description&#39;: &#39;&#39;,</span>
<span class="go">  &#39;id&#39;: &#39;AzpGEGqU/0QAAAAAAAAGMA&#39;,</span>
<span class="go">  &#39;time&#39;: 981126744.98,</span>
<span class="go">  &#39;user_name&#39;: &#39;&#39;},</span>
<span class="go"> {&#39;description&#39;: &#39;&#39;,</span>
<span class="go">  &#39;id&#39;: &#39;AzpGC/hUOKoAAAAAAAAFDQ&#39;,</span>
<span class="go">  &#39;time&#39;: 981126478.202,</span>
<span class="go">  &#39;user_name&#39;: &#39;&#39;}</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>To store a description and a user name on a commit, get the current transaction
and call the <code class="xref py py-meth docutils literal"><span class="pre">note(text)()</span></code> method to store a description, and the
<code class="xref py py-meth docutils literal"><span class="pre">setUser(user_name)()</span></code> method to store the user name. While <code class="xref py py-meth docutils literal"><span class="pre">setUser()</span></code>
overwrites the current user name and replaces it with the new value, the
<code class="xref py py-meth docutils literal"><span class="pre">note()</span></code> method always adds the text to the transaction&#8217;s description, so it
can be called several times to log several different changes made in the course
of a single transaction.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">transaction</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">setUser</span><span class="p">(</span><span class="s1">&#39;amk&#39;</span><span class="p">)</span>
<span class="n">transaction</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">note</span><span class="p">(</span><span class="s1">&#39;Change ownership&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To undo a transaction, call the <code class="xref py py-meth docutils literal"><span class="pre">DB.undo(id)()</span></code> method, passing it the ID of
the transaction to undo.  If the transaction can&#8217;t be undone, a
<code class="xref py py-exc docutils literal"><span class="pre">ZODB.POSException.UndoError</span></code> exception will be raised, with the message
&#8220;non-undoable transaction&#8221;.  Usually this will happen because later transactions
modified the objects affected by the transaction you&#8217;re trying to undo.</p>
<p>After you call <code class="xref py py-meth docutils literal"><span class="pre">undo()</span></code> you must commit the transaction for the undo to
actually be applied.  <a class="footnote-reference" href="#id2" id="id1">[1]</a>  There is one glitch in the undo process.  The thread
that calls undo may not see the changes to the object until it calls
<code class="xref py py-meth docutils literal"><span class="pre">Connection.sync()</span></code> or commits another transaction.</p>
</div>
<div class="section" id="versions">
<h2>Versions<a class="headerlink" href="#versions" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Versions should be avoided.  They&#8217;re going to be deprecated, replaced by better
approaches to long-running transactions.</p>
</div>
<p>While many subtransactions can be contained within a single regular transaction,
it&#8217;s also possible to contain many regular transactions within a long-running
transaction, called a version in ZODB terminology.  Inside a version, any number
of transactions can be created and committed or rolled back, but the changes
within a version are not made visible to other connections to the same ZODB.</p>
<p>Not all storages support versions, but you can test for versioning ability by
calling <code class="xref py py-meth docutils literal"><span class="pre">supportsVersions()</span></code> method of the <a class="reference internal" href="../../reference/zodb.html#DB" title="DB"><code class="xref py py-class docutils literal"><span class="pre">DB</span></code></a> instance, which
returns true if the underlying storage supports versioning.</p>
<p>A version can be selected when creating the <code class="xref py py-class docutils literal"><span class="pre">Connection</span></code> instance using
the <code class="xref py py-meth docutils literal"><span class="pre">DB.open([*version*])()</span></code> method. The <em>version</em> argument must be a string
that will be used as the name of the version.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">vers_conn</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="s1">&#39;Working version&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Transactions can then be committed and aborted using this versioned connection.
Other connections that don&#8217;t specify a version, or provide a different version
name, will not see changes committed within the version named <code class="docutils literal"><span class="pre">Working</span>
<span class="pre">version</span></code>.  To commit or abort a version, which will either make the changes
visible to all clients or roll them back, call the <code class="xref py py-meth docutils literal"><span class="pre">DB.commitVersion()</span></code> or
<code class="xref py py-meth docutils literal"><span class="pre">DB.abortVersion()</span></code> methods. XXX what are the source and dest arguments for?</p>
<p>The ZODB makes no attempt to reconcile changes between different versions.
Instead, the first version which modifies an object will gain a lock on that
object.  Attempting to modify the object from a different version or from an
unversioned connection will cause a <code class="xref py py-exc docutils literal"><span class="pre">ZODB.POSException.VersionLockError</span></code> to
be raised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ZODB.POSException</span> <span class="k">import</span> <span class="n">VersionLockError</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span> <span class="n">VersionLockError</span><span class="p">,</span> <span class="p">(</span><span class="n">obj_id</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Cannot commit; object </span><span class="si">%s</span><span class="s1"> &#39;</span>
           <span class="s1">&#39;locked by version </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj_id</span><span class="p">,</span> <span class="n">version</span><span class="p">))</span>
</pre></div>
</div>
<p>The exception provides the ID of the locked object, and the name of the version
having a lock on it.</p>
</div>
<div class="section" id="multithreaded-zodb-programs">
<h2>Multithreaded ZODB Programs<a class="headerlink" href="#multithreaded-zodb-programs" title="Permalink to this headline">¶</a></h2>
<p>ZODB databases can be accessed from multithreaded Python programs. The
<code class="xref py py-class docutils literal"><span class="pre">Storage</span></code> and <a class="reference internal" href="../../reference/zodb.html#DB" title="DB"><code class="xref py py-class docutils literal"><span class="pre">DB</span></code></a> instances can be shared among several threads,
as long as individual <code class="xref py py-class docutils literal"><span class="pre">Connection</span></code> instances are created for each thread.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There are actually two different ways a storage can implement the undo feature.
Most of the storages that ship with ZODB use the transactional form of undo
described in the main text.  Some storages may use a non-transactional undo
makes changes visible immediately.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/zodb.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Transactions and Versioning</a><ul>
<li><a class="reference internal" href="#committing-and-aborting">Committing and Aborting</a></li>
<li><a class="reference internal" href="#subtransactions">Subtransactions</a></li>
<li><a class="reference internal" href="#undoing-changes">Undoing Changes</a></li>
<li><a class="reference internal" href="#versions">Versions</a></li>
<li><a class="reference internal" href="#multithreaded-zodb-programs">Multithreaded ZODB Programs</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">ZODB articles</a><ul>
  <li><a href="index.html">Very old ZODB programming guide</a><ul>
      <li>Previous: <a href="zeo.html" title="previous chapter">ZEO</a></li>
      <li>Next: <a href="modules.html" title="next chapter">Related Modules</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/articles/old-guide/transactions.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009-2016, Zope Foundation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="../../_sources/articles/old-guide/transactions.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>