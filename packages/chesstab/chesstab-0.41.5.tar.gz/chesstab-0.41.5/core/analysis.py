# analysis.py
# Copyright 2015 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""Chess engine analysis for a position.
"""

from pgn.core.constants import (
    TAG_FEN,
    UNKNOWN_RESULT,
    END_TAG,
    START_TAG,
    START_RAV,
    END_RAV,
    START_COMMENT,
    END_COMMENT,
    )


class Analysis(object):
    """Chess engine analysis for FEN position.

    Store variations generated by chess engines for a position.

    """

    def __init__(self, position=None):
        """"""
        super().__init__()

        # Position encoded as index value for position index.
        self.position = position

        # Variations generated by chess engines:
        # key is engine name reported by chess engine when started,
        # value is ((evaluation, PGN of variation), ...) sorted by evaluation.
        # len(value) is multiPV option value used to do analysis.
        self.variations = {}

        # Depth and width of analysis by chess engine
        # key is engine name reported by chess engine when started,
        # value is (depth, multiPV) option values used to do analysis.
        self.scale = {}

    def set_variations_empty(self):
        """Set all variations to None.

        len(variations[engine] is the multiPV value used when analysis done.
        Set variations to None to preserve the multiPV information when a new
        analysis request is done, while noting any analysis deemed necessary
        is not yet done.

        """
        var = self.variations
        for k, v in var.items():
            var[k] = [None] * len(v)

    def translate_analysis_to_pgn(self, move_played=''):
        """"""

        # Addition of this code tips balance in favour of a class to deal with
        # FEN representation of positions.
        to_move = self.position.split()[1]
        
        if move_played:
            move_played = ''.join(
                (move_played,
                 ' ;Move played',
                 ' by white' if to_move == 'w' else
                 ' by black' if to_move == 'b' else
                 '',
                 '\n'))
        variations = self.variations
        scale = self.scale
        new_text = []
        for engine_name in sorted(variations):
            analysis = variations[engine_name]
            new_text.append(engine_name.join((';', '\n')))
            depth, multipv = [str(s) for s in scale[engine_name]]
            lines = [''.join((' '.join((START_COMMENT,
                                        self._evalution_score(a[0], to_move),
                                        depth,
                                        str(e + 1),
                                        ' '.join((END_COMMENT, START_RAV)))),
                              a[1],
                              END_RAV,
                              '\n'))
                     for e, a in enumerate(analysis)]
            new_text.extend(lines)
            if not move_played:
                move_played = ''.join(
                    (analysis[0][1].split()[0],
                     ' ;First variation',
                     ', white to move' if to_move == 'w' else
                     ', black to move' if to_move == 'b' else
                     '',
                     '\n'))
        new_text.append(UNKNOWN_RESULT)
        if move_played:
            new_text.insert(0, move_played)
            new_text.insert(0,
                            ''.join(
                                (START_TAG, TAG_FEN, '"',
                                 self.position,
                                 END_TAG.join('"\n'))))
        return ''.join(new_text)

    def _evalution_score(self, val, to_move):
        """"""
        try:
            return '{:+.2f}'.format(
                (int(val) if to_move != 'b' else -int(val)) / 100)
        except:
            return '?.??'
