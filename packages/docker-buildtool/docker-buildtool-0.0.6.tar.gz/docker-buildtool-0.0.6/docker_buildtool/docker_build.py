import six
import logging
import os
import platform
import tempfile
import time

if six.PY2:
    import glob2 as glob
else:
    import glob

from docker_buildtool import error, utils

logger = logging.getLogger(__name__)

def expand_include(paths, build_root):
    expanded = []
    for path in paths:
        matches = glob.glob(os.path.join(build_root, path))
        if '*' not in path:
            assert len(matches) > 0, 'No matches found for path'

        expanded += matches

    truncated = []
    for e in expanded:
        assert e.startswith(build_root+'/')
        truncated.append(e[len(build_root)+1:])
    return truncated

class DockerBuild(object):
    def __init__(self, dockerfile, build_root, include, docker_repo, workdir=None, ignore=None, tag=None, default_ignore=None):
        self.dockerfile = os.path.abspath(dockerfile)
        self.build_root = os.path.abspath(build_root)
        self.workdir = workdir
        self.include = include
        self.docker_repo = docker_repo
        if tag is None:
            tag = 'latest'
        self.tag = tag
        self.ignore = ignore or []
        self.dockerignore = os.path.join(self.build_root, '.dockerignore')

        # TODO: phase this out
        if default_ignore or default_ignore is None:
            self.default_ignore = ['**/.git', '**/*.egg-info', '**/*.o']
        else:
            self.default_ignore = []

    def backup_dockerignore(self, dryrun):
        bak = None
        if os.path.exists(self.dockerignore):
            bak = os.path.join(self.build_root, '.dockerignore.tmp.{}'.format(time.time()))
            utils.rename(dryrun, self.dockerignore, bak)
        return bak

    def restore_dockerignore(self, dryrun, bak):
        if bak is None:
            utils.unlink(dryrun, self.dockerignore)
        else:
            utils.rename(dryrun, bak, self.dockerignore)

    def write_dockerignore(self, dryrun, lines):
        for line in lines:
            assert isinstance(line, str), 'Invalid dockerignore line type {}: {}'.format(type(line), line)

        contents = '# Auto-generated dockerignore by docker_build.py\n' + '\n'.join(lines) + '\n'
        utils.write(dryrun, self.dockerignore, contents)

    def write_dockerfile(self, dryrun):
        with open(self.dockerfile) as f:
            contents = f.read()
        if self.workdir is not None:
            contents += """

# Ending auto-generated by docker_build.py
WORKDIR {}
""".format(self.workdir)

        tmpfile = utils.named_temporary_file(dryrun, dir=self.build_root)
        utils.write(dryrun, tmpfile.name, contents)
        return tmpfile

    def run(self, dryrun=False):
        include_paths = []
        for entry in self.include:
            path = entry.to_path(build_root=self.build_root)
            include_paths.append(path)

        custom_dockerfile = None
        bak = self.backup_dockerignore(dryrun)
        try:
            # Run this before computing ignore, so we don't include it in the container
            custom_dockerfile = self.write_dockerfile(dryrun)

            # Empirically, dockerignore doesn't seem to expand negated
            # ** (or interior *) patterns. We expand these ourselves.
            include_paths = expand_include(include_paths, self.build_root)

            # Ignore everything that's not whitelisted
            ignore = ['*'] + \
                     ['!'+include for include in include_paths] + \
                     self.ignore + \
                     self.default_ignore

            self.write_dockerignore(dryrun, ignore)

            if self.docker_repo is not None:
                image = '{}:{}'.format(self.docker_repo, self.tag)
                tag = ['-t', image]
            else:
                tag = []

            utils.execute_command(dryrun, ['docker', 'build', '-f', custom_dockerfile.name] + tag + [self.build_root])
        finally:
            if custom_dockerfile:
                custom_dockerfile.close()
            self.restore_dockerignore(dryrun, bak)
