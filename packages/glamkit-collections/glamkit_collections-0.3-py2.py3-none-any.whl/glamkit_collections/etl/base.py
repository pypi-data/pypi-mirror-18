import traceback

import progressbar
from timezone import timezone


class ETL(object):
    """
    Get data from one place, transform it, and save it in another place.
    """
    def origin_data(self):
        """
        :return: An iterable of the datasource that is being extracted
        """
        raise NotImplementedError

    def items_to_extract(self, offset=0, length=None):
        """
        Return an iterable of specific items to extract.
        As a side-effect, set self.items_to_extract_length.

        :param offset: where to start extracting
        :param length: how many to extract
        :return: An iterable of the specific
        """
        endoffset = length and offset + length
        qs = self.origin_data()[offset:endoffset]
        self.items_to_extract_length = qs.count()
        return qs

    def pre_etl(self):
        """
        Prepare for ETL, for example, by prefetching other necessary data.
        By default, sets self.start_time.
        :return:
        """
        self.start_time = timezone.now()
        return

    def transform(self, extracted_instance):
        """
        Transform the extracted instance to a dictionary of **kwargs.
        :param extracted_instance: a record from the origin
        :return: A dict of kwargs to pass to load()
        """
        # by default, we just return the __dict__, something akin to a straight copy
        return extracted_instance.__dict__

    def load(self, **kwargs):
        """
        :param kwargs: kwargs generated by transform()
        :return:
        """
        raise NotImplementedError

    def post_etl(self):
        return

    def etl(self, offset=0, length=None):
        print "Running %s.etl()" % type(self).__name__
        self.pre_etl()
        self.iterable = self.items_to_extract(offset, length)
        # where the magic happens
        with progressbar.ProgressBar(max_value=self.items_to_extract_length) as bar:
            count = 0
            for instance in self.iterable:
                transformed_data = self.transform(instance)
                if transformed_data:
                    self.load(**transformed_data)
                bar.update(count)
                count += 1
        print "Finishing up"
        self.post_etl()
        print "Done %s.etl()" % type(self).__name__


class ModelToModelETL(ETL):
    origin_qs = None
    destination_qs = None

    def origin_data(self):
        """
        :return: An iterable of the datasource that is being extracted
        """
        return self.origin_qs.all()

    def load(self, **kwargs):
        try:
            return self.destination_qs.update_or_create(**kwargs)
        except Exception as e:
            traceback.print_exc()
            import pdb; pdb.set_trace()
