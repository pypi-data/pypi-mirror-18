from datetime import datetime

from wtforms.fields import (
    Field,
    SelectField,
    SelectFieldBase,
    SelectMultipleField,
    RadioField
    )
from wtforms.fields.core import UnboundField
from wtforms.widgets import (
    CheckboxInput,
    ListWidget,
    Option,
    Select,
    TextArea,
    TextInput
    )
from wtforms.validators import InputRequired

from .utils import to_object_id

__all__ = [
    'CheckboxField',
    'DocumentCheckboxField',
    'DocumentSelectField',
    'PriceField',
    'StringListField',
    'TimeField',
    'YesNoField' 
    ]


class CheckboxField(SelectMultipleField):
    """
    The `Checkbox` field supports for a list of checkboxes within a form, for
    single checkboxes use the `wtforms.fields.BooleanField`.
    """

    widget = ListWidget(prefix_label=False)
    option_widget = CheckboxInput()


class DocumentSelectFieldBase(SelectFieldBase):

    def __new__(cls, *args, **kwargs):
        if '_form' in kwargs and '_name' in kwargs:
            field = super(Field, cls).__new__(cls)

            # Set the form attribute against the field
            field._form = kwargs['_form']

            return field
        else:
            return UnboundField(cls, *args, **kwargs)

    def __init__(self, label=None, frame_cls=None, filter=None, sort=None,
            projection=None, limit=None, id_attr='_id', label_attr=None,
            validators=None, coerce=to_object_id, **kwargs):

        assert frame_cls is not None, \
                'You must specify the `frame_cls` to be used'

        SelectFieldBase.__init__(self, label, validators, **kwargs)
        self.coerce = coerce

        # Arguments used to build the choices
        self._frame_cls = frame_cls
        self._filter = filter
        self._sort = sort
        self._projection = projection
        self._limit = limit
        self._id_attr = id_attr
        self._label_attr = label_attr

    @property
    def choices(self):
        """Build the choices for the field a selection of documents"""

        # Check if the filter is a callable object in which case call it and use
        # the result as the filter.
        filter = self._filter
        if callable(filter):
            filter = filter(self._form, self)

        # Build the filter args
        filter_args = {
            'sort': self._sort,
            'projection': self._projection,
            'limit': self._limit
            }
        filter_args = {k: v for k, v in filter_args.items() if v}

        # Select the documents
        documents = self._frame_cls.many(filter, **filter_args)

        # Build the choices
        return [
            (
                getattr(d, self._id_attr),
                getattr(d, self._label_attr) if self._label_attr else str(d)
            )
            for d in documents]


class DocumentCheckboxField(DocumentSelectFieldBase, CheckboxField):
    """
    The `DocumentCheckboxField` fields supports a list of checkboxes where the
    choices are generated by select documents from the database.
    """


class DocumentSelectField(DocumentSelectFieldBase, SelectField):
    """
    The `DocumentSelectField` fields supports a select field where the options
    are generated by select documents from the database.
    """

    def __init__(self, label=None, frame_cls=None, filter=None, sort=None,
            projection=None, limit=None, id_attr='_id', label_attr=None,
            validators=None, coerce=to_object_id, empty_label='Select...',
            **kwargs):

        super().__init__(label, frame_cls, filter, sort, projection, limit,
                id_attr, label_attr, validators, coerce, **kwargs)

        # If an empty label is specified then the field will display an empty
        # option (with the given label).
        self._empty_label = empty_label

    @property
    def choices(self):
        """Build the choices for the field a selection of documents"""
        choices = super().choices

        # If defined add an empty option to the select
        if self._empty_label is not None:
            choices.insert(0, ('', self._empty_label))

        return choices

    def process_data(self, value):
        # If no value was provided set data to `None` and return
        if value is None:
            self.data = None
            return

        # If we have a value try to coerce to the required type, if we can't set
        # data as `None`
        try:
            self.data = self.coerce(value)
        except (ValueError, TypeError):
            self.data = None

    def pre_validate(self, form):
        # Allow None as a value if an empty label is specified
        if self.data is None and self._empty_label is not None:
            return

        # Check the choice is within the defined choices for the field
        for v, _ in self.choices:
            if self.data == v:
                break
        else:
            raise ValueError(self.gettext('Not a valid choice'))


class PriceField(Field):
    """
    The `PriceField` accepts a price string which it converts to an integer
    representing the price in it's lowest denomination for example pound
    sterling would be convert to pence, dollars and euros to cents.

    Optionally the `denomination_units` argument can be set to change the lowest
    domination, for example setting it to `1` would mean pounds were returned as
    pounds but you'd also need to specify `coerce` as `float` to not lose pence.
    """
    widget = TextInput()

    def __init__(self, label=None, validators=None,
                denomination_units=100, coerce=int, **kwargs):
        super(PriceField, self).__init__(label, validators, **kwargs)

        self._denomination_units = denomination_units
        self._coerce = coerce

    def _value(self):
        if self.raw_data:
            return self.raw_data[0]
        elif self.data is not None:
            return '{:.2f}'.format(self.data / self._denomination_units)
        else:
            return ''

    def process_formdata(self, valuelist):
        if valuelist:
            value = valuelist[0]
            try:
                value = float(valuelist[0])
                self.data = self._coerce(value * self._denomination_units)
            except ValueError:
                self.data = None
                raise ValueError(self.gettext('Not a valid price value'))


class StringListField(Field):
    """
    The `StringListField` supports a list of values being defined as a string.
    """

    widget = TextArea()

    def __init__(self, label='', validators=None, separator='\n',
            remove_blanks=True, remove_duplicates=True, case_sensitive=False,
            coerce=str, sort=False, **kwargs):

        super().__init__(label, validators, **kwargs)

        # The string that separates each value in the string
        self._separator = separator

        # Flags indicating if blank and/or duplicate values should be removed
        self._remove_blanks = remove_blanks
        self._remove_duplicates = remove_duplicates

        # If not case sensitive then duplicates will be removed regardless of
        # differences in case.
        self._case_sensitive = case_sensitive

        # Flag indicating if the values should be sorted
        self._sort = sort

        # A function user to coerce the value to the required format
        self._coerce = coerce

    def _value(self):
        if self.data:
            return self._separator.join(self.data)
        else:
            return ''

    def process_formdata(self, valuelist):
        if valuelist:
            self.data = [v.strip() for v in valuelist[0].split(self._separator)]

            # Remove blanks
            if self._remove_blanks:
                self.data = [v for v in self.data if v]

            # Remove duplicates
            if self._remove_duplicates:
                dataset = set({})
                data = []
                for v in self.data:

                    # Check for a duplicate based on the case sensitive flag
                    if self._case_sensitive:
                        if v in dataset:
                            continue
                        dataset.add(v)

                    else:
                        if v.lower() in dataset:
                            continue
                        dataset.add(v.lower())

                    data.append(v)

                self.data = data

            # Attempt to coerce all values
            try:
                self.data = [self._coerce(d) for d in self.data]
            except:
                self.data = None
                raise ValueError(
                        self.gettext('Not all values in the list are valid'))

            # Sort values
            if self._sort:
                self.data.sort()

        else:
            self.data = []


class TimeField(Field):
    """
    The `TimeField` accepts a time string in 24hr format (by default HH:MM) and
    if valid returns a `datetime.time` instance.
    """

    widget = TextInput()

    def __init__(self, label=None, validators=None, format='%H:%M', **kwargs):
        super().__init__(label, validators, **kwargs)
        self.format = format

    def _value(self):
        if self.raw_data:
            return ' '.join(self.raw_data)
        elif self.data is not None:
            return self.data.strftime(self.format)
        return ''

    def process_formdata(self, values):
        if not values:
            return

        time_str = ' '.join(values)
        try:
            self.data = datetime.strptime(time_str, self.format).time()
        except ValueError:
            self.data = None
            raise ValueError(self.gettext('Not a valid time value.'))


class YesNoField(RadioField):
    """
    The `YesNoField` provides a radio field that requires either a yes or no 
    answer and returns a value of True or False respectively. 

    The typical use for yes no fields are where you require a user to actively 
    answer a question as opposed to using a boolean field where leaving the 
    checkbox unticked results in False being returned.

    By default the options presented are 'Yes' and 'No' but these can be 
    configured by changing the `choices` argument, 
    e.g `choices=[('y', 'OK'), ('n', 'Cancel')]`
    """
    def __init__(self, label=None, validators=None, coerce=None, 
            choices=None, **kwargs):

        # By default we use the strings 'y' and 'n' to represent True and 
        # False. If these are modified then the `coerce` method also needs to 
        # be modified.
        if not choices:
            choices = [('y', 'Yes'), ('n', 'No')]

        if not coerce:
            coerce = lambda x: {'y': True, 'n': False}.get(x, None)

        # By default we require the user to choose an option.
        if validators is None:
            validators = [InputRequired()]

        super().__init__(label, validators, choices=choices, coerce=coerce, 
                **kwargs)

    def iter_choices(self):
        for value, label in self.choices:
            yield (value, label, self.coerce(value) is self.data)

    def pre_validate(self, form):
        # If the field has a value of `None` then we don't check if it's a 
        # valid choice to prevent `None` being flagged as 'Not a valid choice'
        # if the field is not required.
        if self.data is None:
            return

        for v, _ in self.choices:
            if self.data is self.coerce(v):
                break
        else:
            raise ValueError(self.gettext('Not a valid choice'))