# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2013-2016, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------


# The build prepends this module verbatim to each nupic.bindings python
# extension proxy module to load pycapnp's extension shared library in global
# scope before loading our own extension DLL (that doesn't contain capnproto
# code) so that our capnproto references will resolve against capnproto included
# in pycapnp. This ensures that the methods of the same capnproto build that
# creates the capnproto objects in nupic will be used on those objects from both
# nupic and nupic.bindings shared objects.


def _nupic_bindings_load_capnp_shared_object():
  import platform
  # Windows nupic.bindings extensions include CAPNP_LITE capnproto subset and
  # must not depend on pycapnp
  if platform.system() != "Windows":
    import ctypes, imp, os
    capnpPackageDir = imp.find_module('capnp')[1]
    capnpDLLPath=os.path.join(capnpPackageDir, 'lib', 'capnp.so')
    ctypes.CDLL(capnpDLLPath, ctypes.RTLD_GLOBAL)

_nupic_bindings_load_capnp_shared_object()

del _nupic_bindings_load_capnp_shared_object
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_experimental', [dirname(__file__)])
        except ImportError:
            import _experimental
            return _experimental
        if fp is not None:
            try:
                _mod = imp.load_module('_experimental', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _experimental = swig_import_helper()
    del swig_import_helper
else:
    import _experimental
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x



import os

_EXPERIMENTAL = _experimental


uintDType = "uint32"


import numpy

# Without this, Python scripts that haven't imported nupic.bindings.algorithms
# will get a SwigPyObject rather than a SWIG-wrapped Connections instance
# when accessing the ExtendedTemporalMemory's connections.
import nupic.bindings.algorithms


def _asNumpyArray(iterable, dtype):
  if isinstance(iterable, numpy.ndarray):
    if iterable.dtype == dtype:
      return iterable
    else:
      return iterable.astype(dtype)
  else:
    return numpy.array(list(iterable), dtype=dtype)


class ExtendedTemporalMemory(object):
    """Proxy of C++ nupic::experimental::extended_temporal_memory::ExtendedTemporalMemory class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self) -> ExtendedTemporalMemory
        __init__(self, columnDimensions, basalInputDimensions, apicalInputDimensions, cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, connectedPermanence=0.50, minThreshold=10, maxNewSynapseCount=20, permanenceIncrement=0.10, permanenceDecrement=0.10, predictedSegmentDecrement=0.0, formInternalBasalConnections=True, learnOnOneCell=False, seed=42, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True) -> ExtendedTemporalMemory
        """
        this = _experimental.new_ExtendedTemporalMemory(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def initialize(self, columnDimensions, basalInputDimensions, apicalInputDimensions, cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, connectedPermanence=0.50, minThreshold=10, maxNewSynapseCount=20, permanenceIncrement=0.10, permanenceDecrement=0.10, predictedSegmentDecrement=0.0, formInternalBasalConnections=True, learnOnOneCell=False, seed=42, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True):
        """initialize(self, columnDimensions, basalInputDimensions, apicalInputDimensions, cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, connectedPermanence=0.50, minThreshold=10, maxNewSynapseCount=20, permanenceIncrement=0.10, permanenceDecrement=0.10, predictedSegmentDecrement=0.0, formInternalBasalConnections=True, learnOnOneCell=False, seed=42, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, checkInputs=True)"""
        return _experimental.ExtendedTemporalMemory_initialize(self, columnDimensions, basalInputDimensions, apicalInputDimensions, cellsPerColumn, activationThreshold, initialPermanence, connectedPermanence, minThreshold, maxNewSynapseCount, permanenceIncrement, permanenceDecrement, predictedSegmentDecrement, formInternalBasalConnections, learnOnOneCell, seed, maxSegmentsPerCell, maxSynapsesPerSegment, checkInputs)

    __swig_destroy__ = _experimental.delete_ExtendedTemporalMemory

    def version(self):
        """version(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_version(self)


    def seed_(self, seed):
        """seed_(self, seed)"""
        return _experimental.ExtendedTemporalMemory_seed_(self, seed)


    def reset(self):
        """reset(self)"""
        return _experimental.ExtendedTemporalMemory_reset(self)


    def activateCells(self, activeColumnsSize, activeColumns, reinforceCandidatesExternalBasalSize, reinforceCandidatesExternalBasal, reinforceCandidatesExternalApicalSize, reinforceCandidatesExternalApical, growthCandidatesExternalBasalSize, growthCandidatesExternalBasal, growthCandidatesExternalApicalSize, growthCandidatesExternalApical, learn):
        """activateCells(self, activeColumnsSize, activeColumns, reinforceCandidatesExternalBasalSize, reinforceCandidatesExternalBasal, reinforceCandidatesExternalApicalSize, reinforceCandidatesExternalApical, growthCandidatesExternalBasalSize, growthCandidatesExternalBasal, growthCandidatesExternalApicalSize, growthCandidatesExternalApical, learn)"""
        return _experimental.ExtendedTemporalMemory_activateCells(self, activeColumnsSize, activeColumns, reinforceCandidatesExternalBasalSize, reinforceCandidatesExternalBasal, reinforceCandidatesExternalApicalSize, reinforceCandidatesExternalApical, growthCandidatesExternalBasalSize, growthCandidatesExternalBasal, growthCandidatesExternalApicalSize, growthCandidatesExternalApical, learn)


    def depolarizeCells(self, activeCellsExternalBasalSize, activeCellsExternalBasal, activeCellsExternalApicalSize, activeCellsExternalApical, learn=True):
        """depolarizeCells(self, activeCellsExternalBasalSize, activeCellsExternalBasal, activeCellsExternalApicalSize, activeCellsExternalApical, learn=True)"""
        return _experimental.ExtendedTemporalMemory_depolarizeCells(self, activeCellsExternalBasalSize, activeCellsExternalBasal, activeCellsExternalApicalSize, activeCellsExternalApical, learn)


    def compute(self, activeColumnsSize, activeColumns, activeCellsExternalBasalSize=0, activeCellsExternalBasal=0, activeCellsExternalApicalSize=0, activeCellsExternalApical=0, reinforceCandidatesExternalBasalSize=0, reinforceCandidatesExternalBasal=0, reinforceCandidatesExternalApicalSize=0, reinforceCandidatesExternalApical=0, growthCandidatesExternalBasalSize=0, growthCandidatesExternalBasal=0, growthCandidatesExternalApicalSize=0, growthCandidatesExternalApical=0, learn=True):
        """compute(self, activeColumnsSize, activeColumns, activeCellsExternalBasalSize=0, activeCellsExternalBasal=0, activeCellsExternalApicalSize=0, activeCellsExternalApical=0, reinforceCandidatesExternalBasalSize=0, reinforceCandidatesExternalBasal=0, reinforceCandidatesExternalApicalSize=0, reinforceCandidatesExternalApical=0, growthCandidatesExternalBasalSize=0, growthCandidatesExternalBasal=0, growthCandidatesExternalApicalSize=0, growthCandidatesExternalApical=0, learn=True)"""
        return _experimental.ExtendedTemporalMemory_compute(self, activeColumnsSize, activeColumns, activeCellsExternalBasalSize, activeCellsExternalBasal, activeCellsExternalApicalSize, activeCellsExternalApical, reinforceCandidatesExternalBasalSize, reinforceCandidatesExternalBasal, reinforceCandidatesExternalApicalSize, reinforceCandidatesExternalApical, growthCandidatesExternalBasalSize, growthCandidatesExternalBasal, growthCandidatesExternalApicalSize, growthCandidatesExternalApical, learn)


    def numberOfCells(self):
        """numberOfCells(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_numberOfCells(self)


    def getActiveBasalSegments(self):
        """getActiveBasalSegments(self) -> ConnectionsSegmentVector"""
        return _experimental.ExtendedTemporalMemory_getActiveBasalSegments(self)


    def getMatchingBasalSegments(self):
        """getMatchingBasalSegments(self) -> ConnectionsSegmentVector"""
        return _experimental.ExtendedTemporalMemory_getMatchingBasalSegments(self)


    def getActiveApicalSegments(self):
        """getActiveApicalSegments(self) -> ConnectionsSegmentVector"""
        return _experimental.ExtendedTemporalMemory_getActiveApicalSegments(self)


    def getMatchingApicalSegments(self):
        """getMatchingApicalSegments(self) -> ConnectionsSegmentVector"""
        return _experimental.ExtendedTemporalMemory_getMatchingApicalSegments(self)


    def getColumnDimensions(self):
        """getColumnDimensions(self) -> VectorOfUInt32"""
        return _experimental.ExtendedTemporalMemory_getColumnDimensions(self)


    def getBasalInputDimensions(self):
        """getBasalInputDimensions(self) -> VectorOfUInt32"""
        return _experimental.ExtendedTemporalMemory_getBasalInputDimensions(self)


    def getApicalInputDimensions(self):
        """getApicalInputDimensions(self) -> VectorOfUInt32"""
        return _experimental.ExtendedTemporalMemory_getApicalInputDimensions(self)


    def numberOfColumns(self):
        """numberOfColumns(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_numberOfColumns(self)


    def getCellsPerColumn(self):
        """getCellsPerColumn(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_getCellsPerColumn(self)


    def getActivationThreshold(self):
        """getActivationThreshold(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_getActivationThreshold(self)


    def setActivationThreshold(self, arg2):
        """setActivationThreshold(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setActivationThreshold(self, arg2)


    def getInitialPermanence(self):
        """getInitialPermanence(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ExtendedTemporalMemory_getInitialPermanence(self)


    def setInitialPermanence(self, arg2):
        """setInitialPermanence(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setInitialPermanence(self, arg2)


    def getConnectedPermanence(self):
        """getConnectedPermanence(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ExtendedTemporalMemory_getConnectedPermanence(self)


    def setConnectedPermanence(self, arg2):
        """setConnectedPermanence(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setConnectedPermanence(self, arg2)


    def getMinThreshold(self):
        """getMinThreshold(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_getMinThreshold(self)


    def setMinThreshold(self, arg2):
        """setMinThreshold(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setMinThreshold(self, arg2)


    def getMaxNewSynapseCount(self):
        """getMaxNewSynapseCount(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_getMaxNewSynapseCount(self)


    def setMaxNewSynapseCount(self, arg2):
        """setMaxNewSynapseCount(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setMaxNewSynapseCount(self, arg2)


    def getFormInternalBasalConnections(self):
        """getFormInternalBasalConnections(self) -> bool"""
        return _experimental.ExtendedTemporalMemory_getFormInternalBasalConnections(self)


    def setFormInternalBasalConnections(self, formInternalBasalConnections):
        """setFormInternalBasalConnections(self, formInternalBasalConnections)"""
        return _experimental.ExtendedTemporalMemory_setFormInternalBasalConnections(self, formInternalBasalConnections)


    def getLearnOnOneCell(self):
        """getLearnOnOneCell(self) -> bool"""
        return _experimental.ExtendedTemporalMemory_getLearnOnOneCell(self)


    def setLearnOnOneCell(self, learnOnOneCell):
        """setLearnOnOneCell(self, learnOnOneCell)"""
        return _experimental.ExtendedTemporalMemory_setLearnOnOneCell(self, learnOnOneCell)


    def getPermanenceIncrement(self):
        """getPermanenceIncrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ExtendedTemporalMemory_getPermanenceIncrement(self)


    def setPermanenceIncrement(self, arg2):
        """setPermanenceIncrement(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setPermanenceIncrement(self, arg2)


    def getPermanenceDecrement(self):
        """getPermanenceDecrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ExtendedTemporalMemory_getPermanenceDecrement(self)


    def setPermanenceDecrement(self, arg2):
        """setPermanenceDecrement(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setPermanenceDecrement(self, arg2)


    def getPredictedSegmentDecrement(self):
        """getPredictedSegmentDecrement(self) -> nupic::algorithms::connections::Permanence"""
        return _experimental.ExtendedTemporalMemory_getPredictedSegmentDecrement(self)


    def setPredictedSegmentDecrement(self, arg2):
        """setPredictedSegmentDecrement(self, arg2)"""
        return _experimental.ExtendedTemporalMemory_setPredictedSegmentDecrement(self, arg2)


    def getCheckInputs(self):
        """getCheckInputs(self) -> bool"""
        return _experimental.ExtendedTemporalMemory_getCheckInputs(self)


    def setCheckInputs(self, checkInputs):
        """setCheckInputs(self, checkInputs)"""
        return _experimental.ExtendedTemporalMemory_setCheckInputs(self, checkInputs)


    def _validateCell(self, cell):
        """_validateCell(self, cell) -> bool"""
        return _experimental.ExtendedTemporalMemory__validateCell(self, cell)


    def save(self, outStream):
        """save(self, outStream)"""
        return _experimental.ExtendedTemporalMemory_save(self, outStream)


    def load(self, inStream):
        """load(self, inStream)"""
        return _experimental.ExtendedTemporalMemory_load(self, inStream)


    def read(self, *args):
        """
        read(self)
        read(self, proto)
        """
        return _experimental.ExtendedTemporalMemory_read(self, *args)


    def persistentSize(self):
        """persistentSize(self) -> nupic::UInt"""
        return _experimental.ExtendedTemporalMemory_persistentSize(self)


    def printParameters(self):
        """printParameters(self)"""
        return _experimental.ExtendedTemporalMemory_printParameters(self)


    def columnForCell(self, cell):
        """columnForCell(self, cell) -> nupic::Int"""
        return _experimental.ExtendedTemporalMemory_columnForCell(self, cell)


    def printState(self, *args):
        """
        printState(self, state)
        printState(self, state)
        """
        return _experimental.ExtendedTemporalMemory_printState(self, *args)

    basalConnections = _swig_property(_experimental.ExtendedTemporalMemory_basalConnections_get, _experimental.ExtendedTemporalMemory_basalConnections_set)
    apicalConnections = _swig_property(_experimental.ExtendedTemporalMemory_apicalConnections_get, _experimental.ExtendedTemporalMemory_apicalConnections_set)

    def __init__(self,
                 columnDimensions=(2048,),
                 basalInputDimensions=(),
                 apicalInputDimensions=(),
                 cellsPerColumn=32,
                 activationThreshold=13,
                 initialPermanence=0.21,
                 connectedPermanence=0.50,
                 minThreshold=10,
                 maxNewSynapseCount=20,
                 permanenceIncrement=0.10,
                 permanenceDecrement=0.10,
                 predictedSegmentDecrement=0.00,
                 formInternalBasalConnections=True,
                 learnOnOneCell=False,
                 maxSegmentsPerCell=255,
                 maxSynapsesPerSegment=255,
                 seed=42,
                 checkInputs=True):
      self.this = _EXPERIMENTAL.new_ExtendedTemporalMemory(
        columnDimensions, basalInputDimensions, apicalInputDimensions,
        cellsPerColumn, activationThreshold,
        initialPermanence, connectedPermanence,
        minThreshold, maxNewSynapseCount, permanenceIncrement,
        permanenceDecrement, predictedSegmentDecrement,
        formInternalBasalConnections, learnOnOneCell, seed, maxSegmentsPerCell,
        maxSynapsesPerSegment, checkInputs)


    def __getstate__(self):
    # Save the local attributes but override the C++ temporal memory with the
    # string representation.
      d = dict(self.__dict__)
      d["this"] = self.getCState()
      return d


    def __setstate__(self, state):
    # Create an empty C++ temporal memory and populate it from the serialized
    # string.
      self.this = _EXPERIMENTAL.new_ExtendedTemporalMemory()
      if isinstance(state, str):
        self.loadFromString(state)
        self.valueToCategory = {}
      else:
        self.loadFromString(state["this"])
    # Use the rest of the state to set local Python attributes.
        del state["this"]
        self.__dict__.update(state)


    def activateCells(self,
                      activeColumns,
                      reinforceCandidatesExternalBasal=(),
                      reinforceCandidatesExternalApical=(),
                      growthCandidatesExternalBasal=(),
                      growthCandidatesExternalApical=(),
                      learn=True):
      """
      Calculate the active cells, using the current active columns and dendrite
      segments. Grow and reinforce synapses.

      @param activeColumns (sequence)
      A sorted sequence of active column indices.

      @param reinforceCandidatesExternalBasal (sequence)
      Sorted list of external cells. Any learning basal dendrite segments will
      use this list to decide which synapses to reinforce and which synapses to
      punish. Typically this list should be the 'activeCellsExternalBasal' from
      the prevous time step.

      @param reinforceCandidatesExternalApical (sequence)
      Sorted list of external cells. Any learning apical dendrite segments will
      use this list to decide which synapses to reinforce and which synapses to
      punish. Typically this list should be the 'activeCellsExternalApical' from
      the prevous time step.

      @param growthCandidatesExternalBasal (sequence)
      Sorted list of external cells. Any learning basal dendrite segments can
      grow synapses to cells in this list. Typically this list should be a
      subset of the 'activeCellsExternalBasal' from the previous
      'depolarizeCells'.

      @param growthCandidatesExternalApical (sequence)
      Sorted list of external cells. Any learning apical dendrite segments can
      grow synapses to cells in this list. Typically this list should be a
      subset of the 'activeCellsExternalApical' from the previous
      'depolarizeCells'.

      @param learn (boolean)
      Whether to grow / reinforce / punish synapses.
      """
      columnsArray = numpy.array(sorted(activeColumns), dtype=uintDType)

      self.convertedActivateCells(
          _asNumpyArray(activeColumns, uintDType),
          _asNumpyArray(reinforceCandidatesExternalBasal, uintDType),
          _asNumpyArray(reinforceCandidatesExternalApical, uintDType),
          _asNumpyArray(growthCandidatesExternalBasal, uintDType),
          _asNumpyArray(growthCandidatesExternalApical, uintDType),
          learn)


    def depolarizeCells(self,
                        activeCellsExternalBasal=(),
                        activeCellsExternalApical=(),
                        learn=True):
      """
      Calculate dendrite segment activity, using the current active cells.

      @param activeCellsExternalBasal (sequence)
      Sorted list of active external cells for activating basal dendrites.

      @param activeCellsExternalApical (sequence)
      Sorted list of active external cells for activating apical dendrites.

      @param learn (bool)
      If true, segment activations will be recorded. This information is used
      during segment cleanup.

      """

      self.convertedDepolarizeCells(
          _asNumpyArray(activeCellsExternalBasal, uintDType),
          _asNumpyArray(activeCellsExternalApical, uintDType),
          learn)


    def compute(self,
                activeColumns,
                activeCellsExternalBasal=(),
                activeCellsExternalApical=(),
                reinforceCandidatesExternalBasal=(),
                reinforceCandidatesExternalApical=(),
                growthCandidatesExternalBasal=(),
                growthCandidatesExternalApical=(),
                learn=True):
      """
      Perform one time step of the Temporal Memory algorithm.

      This method calls activateCells, then calls depolarizeCells. Using the
      TemporalMemory via its compute method ensures that you'll always be able to
      call getPredictiveCells to get predictions for the next time step.

      @param activeColumns (sequence)
      Sorted list of active columns.

      @param activeCellsExternalBasal (sequence)
      Sorted list of active external cells for activating basal dendrites at the
      end of this time step.

      @param activeCellsExternalApical (sequence)
      Sorted list of active external cells for activating apical dendrites at the
      end of this time step.

      @param reinforceCandidatesExternalBasal (sequence)
      Sorted list of external cells. Any learning basal dendrite segments will use
      this list to decide which synapses to reinforce and which synapses to
      punish. Typically this list should be the 'activeCellsExternalBasal' from
      the prevous time step.

      @param reinforceCandidatesExternalApical (sequence)
      Sorted list of external cells. Any learning apical dendrite segments will use
      this list to decide which synapses to reinforce and which synapses to
      punish. Typically this list should be the 'activeCellsExternalApical' from
      the prevous time step.

      @param growthCandidatesExternalBasal (sequence)
      Sorted list of external cells. Any learning basal dendrite segments can grow
      synapses to cells in this list. Typically this list should be a subset of
      the 'activeCellsExternalBasal' from the prevous time step.

      @param growthCandidatesExternalApical (sequence)
      Sorted list of external cells. Any learning apical dendrite segments can grow
      synapses to cells in this list. Typically this list should be a subset of
      the 'activeCellsExternalApical' from the prevous time step.

      @param learn (bool)
      Whether or not learning is enabled
      """

    # Don't call the C++ compute. Implement it in Python. This ensures that we
    # call any Python overrides on the `activateCells` and `depolarizeCells`
    # methods.
      self.activateCells(activeColumns,
                         reinforceCandidatesExternalBasal,
                         reinforceCandidatesExternalApical,
                         growthCandidatesExternalBasal,
                         growthCandidatesExternalApical,
                         learn)
      self.depolarizeCells(activeCellsExternalBasal,
                           activeCellsExternalApical,
                           learn)


    def reset(self):
      _EXPERIMENTAL.ExtendedTemporalMemory_reset(self)


    @classmethod
    def read(cls, proto):
      instance = cls()
      instance.convertedRead(proto)
      return instance


    def getActiveCells(self):
        """getActiveCells(self) -> PyObject *"""
        return _experimental.ExtendedTemporalMemory_getActiveCells(self)


    def getPredictiveCells(self):
        """getPredictiveCells(self) -> PyObject *"""
        return _experimental.ExtendedTemporalMemory_getPredictiveCells(self)


    def getWinnerCells(self):
        """getWinnerCells(self) -> PyObject *"""
        return _experimental.ExtendedTemporalMemory_getWinnerCells(self)


    def cellsForColumn(self, columnIdx):
        """cellsForColumn(self, columnIdx) -> PyObject *"""
        return _experimental.ExtendedTemporalMemory_cellsForColumn(self, columnIdx)


    def convertedActivateCells(self, py_activeColumns, py_reinforceCandidatesExternalBasal, py_reinforceCandidatesExternalApical, py_growthCandidatesExternalBasal, py_growthCandidatesExternalApical, learn):
        """convertedActivateCells(self, py_activeColumns, py_reinforceCandidatesExternalBasal, py_reinforceCandidatesExternalApical, py_growthCandidatesExternalBasal, py_growthCandidatesExternalApical, learn)"""
        return _experimental.ExtendedTemporalMemory_convertedActivateCells(self, py_activeColumns, py_reinforceCandidatesExternalBasal, py_reinforceCandidatesExternalApical, py_growthCandidatesExternalBasal, py_growthCandidatesExternalApical, learn)


    def convertedDepolarizeCells(self, py_activeCellsExternalBasal, py_activeCellsExternalApical, learn):
        """convertedDepolarizeCells(self, py_activeCellsExternalBasal, py_activeCellsExternalApical, learn)"""
        return _experimental.ExtendedTemporalMemory_convertedDepolarizeCells(self, py_activeCellsExternalBasal, py_activeCellsExternalApical, learn)


    def write(self, *args):
        """
        write(self)
        write(self, proto)
        write(self, pyBuilder)
        """
        return _experimental.ExtendedTemporalMemory_write(self, *args)


    def convertedRead(self, pyReader):
        """convertedRead(self, pyReader)"""
        return _experimental.ExtendedTemporalMemory_convertedRead(self, pyReader)


    def loadFromString(self, inString):
        """loadFromString(self, inString)"""
        return _experimental.ExtendedTemporalMemory_loadFromString(self, inString)


    def getCState(self):
        """getCState(self) -> PyObject *"""
        return _experimental.ExtendedTemporalMemory_getCState(self)

ExtendedTemporalMemory_swigregister = _experimental.ExtendedTemporalMemory_swigregister
ExtendedTemporalMemory_swigregister(ExtendedTemporalMemory)



