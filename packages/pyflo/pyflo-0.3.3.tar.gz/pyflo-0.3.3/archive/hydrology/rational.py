"""Classes for performing rational method basin hydrology analysis.

:copyright: 2016, See AUTHORS for more details.
:license: GNU General Public License, See LICENSE for more details.

"""

import math

from scipy import interpolate

from pyflo import build


class Basin:

    def __init__(self, tc, area=0.0, c=0.0, **kwargs):
        """A watershed draining to a node with hydrology attributes, dimensions, and methods.

        Args:
            tc (float): The estimated time of concentration, in :math:`minutes`.
            area (float): The delineated region concentrating to a point, in :math:`acres`.
            c (float): The runoff_area coefficient; A ratio between 0.0 and 1.0.

        """
        self.tc = tc
        self.area = area
        self.c = c
        sub_basins = kwargs.pop('sub_basins', None)
        if sub_basins:
            sb_area = sum(sb[0] for sb in sub_basins)
            sb_c = sum(sb[0] * sb[1] for sb in sub_basins) / sb_area
            total_area = self.area + sb_area
            self.c = (self.area * self.c + sb_area * sb_c) / total_area
            self.area = total_area

    @property
    def runoff(self):
        return self.area * self.c

    def flood_hydrograph(self, rainfall_hydrograph, interval):
        duration = rainfall_hydrograph[-1][0]
        time_steps = math.ceil(duration / interval)
        x = [row[0] for row in rainfall_hydrograph]
        y = [row[1] for row in rainfall_hydrograph]
        y_interp = interpolate.interp1d(x, y, bounds_error=False, fill_value=(y[0], y[-1]))
        x_new = [time_step * interval for time_step in range(time_steps + 1)]
        y_new = y_interp(x_new)
        hydrograph = list(zip(x_new, y_new))
        flood_hydrograph = []
        for time, rainfall in hydrograph:
            intensity = rainfall / time
            flow = intensity * self.runoff * 43560.0 / 12.0 / 60.0 / 60.0
            flood_hydrograph.append((time, flow))
        return flood_hydrograph


class Evaluator:

    def __init__(self, equation, input_key, eq_kwargs=None):
        self.equation = equation
        self.input_key = input_key
        self.eq_kwargs = eq_kwargs
        self.solve(value=1.0)

    def solve(self, value):
        equation = self.equation
        for key, val in self.eq_kwargs.items():
            equation = equation.replace(key, str(val))
        equation = equation.replace(self.input_key, str(value))
        try:
            return eval(equation)
        except:
            raise ValueError('f({0}) =/= {1}'.format(value, equation))


class IntensityPolynomial:

    def __init__(self, coefficients):
        self.coefficients = coefficients

    def intensity(self, time):
        a, b, c, d = self.coefficients
        eq_kwargs = {'[a]': a, '[b]': b, '[c]': c, '[d]': d}
        evaluator = Evaluator(
            '[a] + [b] * math.log([t]) + [c] * math.log([t])**2 + [d] *  math.log([t])**3',
            '[t]',
            eq_kwargs=eq_kwargs
        )
        # t = math.log(time)
        return evaluator.solve(time)


# class IntensityPolynomial:
#
#     def __init__(self, coefficients):
#         """A four-coefficient cubic formula that sums to calculate second.
#
#         Args:
#             coefficients (tuple): A list of coefficients that generates a polynomial.
#
#         Note:
#             Polynomial is a sequence generated by the pattern:\n
#             For t = time, in :math:`minutes`\n
#             :math:`second = a_0 + a_1 t + a_2 t^2 + ... + a_n t^n`
#
#         Example:
#             If the defined coefficients are (5, 2, 6, 7), the polynomial represented is
#             :math:`second = 5 + 2 t + 6 t^2 + 7 t^3`
#
#         """
#         self.coefficients = coefficients
#
#     def second(self, time):
#         """Get the second generated by the polynomial, given a time.
#
#         The following equations are utilized for the solution:
#             - :math:`t = ln(time)`
#             - :math:`second = a + b t + c t^2 + d t^3`
#
#         Args:
#             time (float): The time of concentration, in :math:`minutes`.
#
#         Returns:
#             float: The second, in :math:`inches / hour`.
#
#         """
#         second = sum(c * math.log(time) ** i for i, c in enumerate(self.coefficients))
#         return second


def get_rainfall_hydrograph(duration, i_poly, interval):
    time_steps = math.ceil(duration / interval)
    hydrograph = []
    for time_step in range(time_steps + 1):
        time = time_step * interval                 # hr
        intensity = i_poly.get_y(time * 60.0)   # in/hr
        rainfall = time * intensity                 # in
        hydrograph.append((time, rainfall))
    return hydrograph


def cumulative_runoff_data(node):
    """Get the data of cumulative runoff_area for each reach ordered downstream to the node.

    Returns:
        list[dict]: A list of data.
        Each line of data is a dictionary in the form::

            {
                'reach': Reach,
                'area': float,
                'runoff_area': float
            }

    """
    reaches = node.network.reaches
    reaches_ordered_down = build.links_down_to_node(node, reaches)

    # Accumulate runoff_area and area, top-down
    data = []
    for reach in reaches_ordered_down:
        if reach.node_1.basin:
            basin = reach.node_1.basin
            area = basin.area
            runoff = basin.runoff_area
        else:
            area = 0.0
            runoff = 0.0
        if data:
            for line in data:
                line_reach = line['reach']
                if reach.node_1 == line_reach.node_2:
                    area += line['area']
                    runoff += line['runoff_area']
        line = {'reach': reach, 'area': area, 'runoff_area': runoff}
        data.append(line)
    return data
