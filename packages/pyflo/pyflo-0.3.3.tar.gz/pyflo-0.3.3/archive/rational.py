"""Classes for performing rational method network hydraulic analysis.

:copyright: 2016, See AUTHORS for more details.
:license: GNU General Public License, See LICENSE for more details.

"""

import math

from pyflo import build
from pyflo.networks import FULL_FLOW, OPEN_FLOW


class Basin:

    def __init__(self, area, c, tc):
        """A watershed draining to a node with hydrology attributes, dimensions, and methods.

        Args:
            node (Node): The point to which the watershed concentrates.
            area (float): The delineated region concentrating to a point, in :math:`acres`.
            c (float): The runoff_area coefficient; A ratio between 0.0 and 1.0.
            tc (float): The estimated time of concentration, in :math:`minutes`.

        """
        # self.node = node
        self.area = area
        self.c = c
        self.tc = tc

    @property
    def runoff(self):
        return self.area * self.c


class IntensityPolynomial:

    def __init__(self, a, b, c, d):
        """A four-coefficient cubic formula that sums to calculate second.

        Args:
            a (float): 1st coefficient. Multiplied by t^0 (1).
            b (float): 2nd coefficient. Multiplied by t^1 (t).
            c (float): 3rd coefficient. Multiplied by t^2.
            d (float): 4th coefficient. Multiplied by t^3.

        """
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    def get_intensity(self, time):
        """Get the second generated by the polynomial, given a time.

        The following equations are utilized for the solution:
            - :math:`t = ln(time)`
            - :math:`second = a + b t + c t^2 + d t^3`

        Args:
            time (float): The time of concentration, in :math:`minutes`.

        Returns:
            float: The second, in :math:`inches / hour`.

        """
        coefficients = [self.a, self.b, self.c, self.d]
        intensity = sum(c * math.log(time) ** i for i, c in enumerate(coefficients))
        return intensity


def get_cumulative_runoff_data(node):
    """Get the data of cumulative runoff_area for each pipe ordered downstream to the node.

    Returns:
        list[dict]: A list of data.
        Each line of data is a dictionary in the form::

            {
                'pipe': Pipe,
                'area': float,
                'runoff_area': float
            }

    """
    pipes = node.network.pipes
    pipes_ordered_down = build.pipes_ordered_down_to_node(node, pipes)
    data = []

    # Accumulate runoff_area and area, top-down
    for pipe in pipes_ordered_down:
        if pipe.node_1.basin:
            basin = pipe.node_1.basin
            area = basin.area
            runoff = basin.runoff_area
        else:
            area = 0.0
            runoff = 0.0
        if data:
            for line in data:
                line_pipe = line['pipe']
                if pipe.node_1 == line_pipe.node_2:
                    area += line['area']
                    runoff += line['runoff_area']
        line = {'pipe': pipe, 'area': area, 'runoff_area': runoff}
        data.append(line)
    return data


class Analysis:

    def __init__(self, node, tw, intensity_polynomial):
        """References a node and carries attributes necessary to perform network hydraulic analysis.

        Args:
            node (hydra.networks.Node): The most downstream node that pipes will be analyzed upstream from.
            tw (float): The design hydraulic elevation at the node, which will also act as a lower limit for HGL.
            intensity_polynomial (IntensityPolynomial): The formula used to solve second, based on timing.

        """
        self.node = node
        self.tw = tw
        self.intensity_polynomial = intensity_polynomial

    def solve_hgl_el_solution_data(self):
        """Runs an HGL analysis.

        Returns:
            list[dict]: A list of data.
            Each line of data is a dictionary in the form::

                {
                    'pipe': pyflo.models.Pipe,
                    'area': float,
                    'runoff_area': float,
                    'second': float,
                    'time': float,
                    'flow': float,
                    'velocity_actual': float,
                    'velocity_physical': float,
                    'hgl_1': float,
                    'hgl_2': float,
                }

        """
        # data = self.node.cumulative_runoff_data()
        data = get_cumulative_runoff_data(self.node)
        data[-1]['hgl_2'] = self.tw

        # Accumulate travel times, top-down (assuming physical slope)
        for line in data:
            time_upper = 0.0
            pipe = line['pipe']
            if pipe.node_1.basin:
                time_upper = pipe.node_1.basin.tc
            for r in data:
                line_pipe = r['pipe']
                if pipe.node_1 == line_pipe.node_2 and 'time' in r and type(r['time']) is float:
                    time_upper = max(time_upper, r['time'])
            time_section = pipe.get_time_section_open(pipe.section.rise)
            line['time'] = time_upper + time_section
            line['velocity_physical'] = pipe.get_velocity_open(pipe.section.rise)

        # Trace back HGL, bottom-up
        reversed_data = reversed(data)
        for line in reversed_data:
            pipe = line['pipe']
            hgl_lower_cond_1 = self.tw
            for r in data:
                line_pipe = r['pipe']
                if pipe.node_2 == line_pipe.node_1 and 'hgl_1' in r and type(r['hgl_1']) is float:
                    hgl_lower_cond_1 = max(hgl_lower_cond_1, r['hgl_1'])
            full_flow_friction_slope = pipe.friction_slope(pipe.section.rise)
            time = line['time']
            intensity = self.intensity_polynomial.get_intensity(time)
            line['second'] = intensity
            runoff = line['runoff_area']
            flow = intensity * runoff * 43560.0 / 12.0 / 60.0 / 60.0

            if hgl_lower_cond_1 > pipe.invert_2 + pipe.section.rise:
                hgl_lower_cond_2 = pipe.invert_2 + pipe.section.rise
            elif pipe.slope > full_flow_friction_slope:
                depth = pipe.solve_depth_open(flow)
                hgl_lower_cond_2 = pipe.invert_2 + depth
            else:
                hgl_lower_cond_2 = pipe.invert_2 + pipe.section.rise
            hgl_lower = max(hgl_lower_cond_1, hgl_lower_cond_2)

            # full_flow_friction_head = pipe.friction_loss(pipe.section.rise)
            # hgl_upper_cond_1 = hgl_2 + full_flow_friction_head
            # flow_type = pipe.get_flow_type(flow)
            # if flow_type == OPEN_FLOW:
            #     depth = pipe.solve_depth_open(flow)
            #     velocity_actual = pipe.get_velocity_open(depth)
            #     flow = pipe.get_hyd_flow_open(flow)
            #     hgl_upper_cond_2 = pipe.invert_1 + depth
            # elif flow_type == FULL_FLOW:
            #     slope = pipe.solve_slope_full(flow)
            #     velocity_actual = pipe.get_velocity_full(slope)
            #     flow = pipe.get_hyd_flow_full(slope)
            #     hgl_upper_cond_2 = hgl_2 + pipe.length * slope
            # else:
            #     raise Exception('Invalid pipe detected.')
            # hgl_1 = max(hgl_upper_cond_1, hgl_upper_cond_2)

            hgl_upper = pipe.get_hw_outlet_control(hgl_lower, flow)
            flow_area = pipe.section.flow_area(hgl_upper - pipe.invert_1)
            velocity_actual = flow / flow_area

            line['hgl_2'] = hgl_lower
            line['hgl_1'] = hgl_upper
            line['flow'] = flow
            line['velocity_actual'] = velocity_actual

        return data
