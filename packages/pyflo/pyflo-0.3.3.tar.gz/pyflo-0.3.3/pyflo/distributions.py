"""Functions for generating and manipulating 2-column ordered pair data.

:copyright: 2016, See AUTHORS for more details.
:license: GNU General Public License, See LICENSE for more details.

"""


import math

import simpleeval
from scipy import interpolate
import numpy


EVAL_FUNCS = {
    'acos': math.acos,
    'acosh': math.acosh,
    'asin': math.asin,
    'asinh': math.asinh,
    'atan': math.atan,
    'atan2': math.atan2,
    'atanh': math.atanh,
    'ceil': math.ceil,
    'copysign': math.copysign,
    'cos': math.cos,
    'cosh': math.cosh,
    'degrees': math.degrees,
    'e': math.e,
    'exp': math.exp,
    'fabs': math.fabs,
    'factorial': math.factorial,
    'floor': math.floor,
    'fmod': math.fmod,
    'frexp': math.frexp,
    'fsum': math.fsum,
    'hypot': math.hypot,
    'isinf': math.isinf,
    'isnan': math.isnan,
    'ldexp': math.ldexp,
    'log': math.log,
    'log10': math.log10,
    'log1p': math.log1p,
    'modf': math.modf,
    'pi': math.pi,
    'pow': math.pow,
    'radians': math.radians,
    'sin': math.sin,
    'sinh': math.sinh,
    'sqrt': math.sqrt,
    'tan': math.tan,
    'tanh': math.tanh,
    'trunc': math.trunc,
}


class Evaluator(object):

    def __init__(self, equation, x_key, eq_kwargs=None, **kwargs):
        """Generates output data from an equation string.

        Args:
            equation (str): A string in Python math format. All variables introduced here must be
                included in either the x_key or eq_kwargs arguments.
            x_key (str): The name of the variable in the equation which inputs will be passed.
            eq_kwargs (dict): Additional variables to pass to the equation string.

        """
        self.equation = equation
        self.x_key = x_key
        self.eq_kwargs = eq_kwargs
        self.x_multi = kwargs.pop('x_multi', None)
        self.get_y(x=1.0)

    def get_y(self, x):
        """Get the corresponding output of the evaluated equation string, given an input.

        Args:
            x (float): An input value.

        Returns:
            float: The corresponding output generated by the equation string.

        Raises:
            ValueError: If the equation string is invalid.

        """
        eq = self.equation
        for key, val in self.eq_kwargs.items():
            eq = eq.replace(key, str(val))
        if self.x_multi:
            x *= self.x_multi
        eq = eq.replace(self.x_key, str(x))
        try:
            return simpleeval.simple_eval(eq, functions=EVAL_FUNCS)
        except:
            raise ValueError('Error in the produced equation: {0}'.format(eq))

    def get_data(self, x_max, x_delta, product=False):
        """Generate ordered pairs over the defined range.

        Args:
            x_max (float): The maximum input to retrieve values.
            x_delta (float): The interval to increment calculations by.
            product (bool): If true the generated output value will be multiplied by the input
                value before between evaluation and storing to 2nd column. Default is false.

        Yields:
            Tuple[float, float]: The next ordered pair.

        """
        x_steps = math.ceil(x_max / x_delta)
        for step in range(x_steps + 1):
            x_new = step * x_delta
            y_new = self.get_y(x_new)
            if product:
                y_new *= x_new
            yield x_new, y_new

    def get_distribution(self, x_max, x_delta, product=False):
        """Generate a distribution with ordered pairs over the defined range.

        Args:
            x_max (float): The maximum input to retrieve values.
            x_delta (float): The interval to increment calculations by.
            product (bool): If true the generated output value will be multiplied by the input
                value before between evaluation and storing to 2nd column. Default is false.

        Returns:
            numpy.ndarray: The generated distribution.

        """
        data_new = list(self.get_data(x_max, x_delta, product))
        dist_new = numpy.array(data_new)
        return dist_new


def increment(array, interval):
    x_col = array[:, 0]
    y_col = array[:, 1]
    fill_value = y_col[0], y_col[-1]
    y_interp = interpolate.interp1d(x_col, y_col, bounds_error=False, fill_value=fill_value)
    x_new = numpy.arange(x_col[0], x_col[-1] + interval, interval)
    y_new = y_interp(x_new)
    return numpy.column_stack((x_new, y_new))
