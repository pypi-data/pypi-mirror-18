# -*- coding: utf-8 -*-
# Copyright (c) 2015, pyretis Development Team.
# Distributed under the LGPLv3 License. See LICENSE for more info.
"""Classes and functions for paths.

The classes and functions defined in this module are useful for
representing paths.


Important classes defined here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PathBase
    A base class for paths.

Path
    Class for a generic path that stores all possible information.

Important methods defined here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

paste_paths
    Function for joining two paths, one is in a backward time
    direction and the other is in the forward time direction.
"""
from abc import ABCMeta, abstractmethod
import logging
import numpy as np
logger = logging.getLogger(__name__)  # pylint: disable=C0103
logger.addHandler(logging.NullHandler())


__all__ = ['PathBase', 'Path', 'ReservoirPath', 'paste_paths']

# the following defines a human-readable form of the possible path status:
_STATUS = {'ACC': 'The path has been accepted',
           'MCR': 'Momenta change rejection',
           'BWI': 'Backward trajectory end at wrong interface',
           'BTL': 'Backward trajectory too long (detailed balance condition)',
           'BTX': 'Backward trajectory too long (max-path exceeded)',
           'KOB': 'Kicked outside of boundaries',
           'FTL': 'Forward trajectory too long (detailed balance condition)',
           'FTX': 'Forward trajectory too long (max-path exceeded)',
           'NCR': 'No crossing with middle interface'}

_GENERATED = {'sh': 'Path was generated with a shooting move',
              'tr': 'Path was generated with a time-reversal move',
              'ki': 'Path was generated by integration after kicking',
              's+': 'Path was generated by a swapping move from +',
              's-': 'Path was generated by a Swapping move from -',
              '00': 'Path was generated by a null move'}


def paste_paths(path_back, path_forw, overlap=True, maxlen=None):
    """Merge a backward with a forward path into a new path.

    The resulting path is equal to the two paths stacked, in correct
    time. Note that the ordering is important here so that:
    ``paste_paths(path1, path2) != paste_paths(path2, path1)``.

    There are two things we need to take care of here:

    - `path_back` must be iterated in reverse (it is assumed to be a
      backward trajectory).
    - we may have to remove one point in `path2` (if the paths overlap).

    Parameters
    ----------
    path_back : object like `Path`.
        This is the backward trajectory.
    path_forw : object like `Path`.
        This is the forward trajectory.
    overlap : boolean, default is True.
        If true, `path_back` and `path_forw` have a common
        starting-point, that is, the first point in `path_forw` is
        identical to the first point in `path_back`. In time-space this
        means that the first point in `path_forw` is identical to the
        last point in path_back (the backward and forward path started
        at the same location in space).
    maxlen : float, optional.
        This is the maximum length for the new path. If it's not given,
        it will just be set to the largest of the `maxlen` of the two
        given paths.

    Note
    ----
    Some information about the path will not be set here. This must be
    set elsewhere. This includes how the path was generated
    (`path.generated`) and the status of the path (`path.status`).
    """
    if maxlen is None:
        if path_back.maxlen == path_forw.maxlen:
            maxlen = path_back.maxlen
        else:
            # They are unequal and both is not None, just pick the largest.
            # In case one is None, the other will be picked.
            # Note that now there is a chance of truncating the path while
            # pasting!
            maxlen = max(path_back.maxlen, path_forw.maxlen)
            msg = 'Unequal length: Using {} for the new path!'.format(maxlen)
            logger.warning(msg)
    time_origin = path_back.time_origin - path_back.length + 1
    new_path = path_back.empty_path(maxlen=maxlen, time_origin=time_origin)
    for phasepoint in path_back.trajectory(reverse=True):
        app = new_path.append(*phasepoint)
        if not app:
            msg = 'Truncated while pasting backwards at: {}'
            msg = msg.format(new_path.length)
            logger.warning(msg)
            return new_path
    first = True
    for phasepoint in path_forw.trajectory():
        if first and overlap:
            first = False
            continue
        app = new_path.append(*phasepoint)
        if not app:
            msg = 'Truncated path at: {}'.format(new_path.length)
            logger.warning(msg)
            return new_path
    return new_path


def check_crossing(cycle, orderp, interfaces, leftside_prev):
    """Check if we have crossed an interface during the last step.

    This function is useful for checking if an interface was crossed
    from the previous step till the current one. This is for instance
    used in the MD simulations for the initial flux.
    If will use a variable to store the previous positions with respect
    to the interfaces and check if interfaces were crossed here.

    Parameters
    ----------
    cycle : int
        This is the current simulation cycle number.
    orderp : float
        The current order parameter.
    interfaces : list of floats
        These are the interfaces to check.
    leftside_prev : list of booleans
        These are used to store the previous positions with respect
        to the interfaces.

    Returns
    -------
    leftside_curr : list of booleans
        These are the updated positions with respect to the interfaces.
    cross : list of tuples
        If a certain interface is crossed, a tuple will be added to this
        list. The tuple is of form
        (cycle number, interface number, direction)
        where direction is '-' for a crossing in the negative direction
        and '+' for a crossing in the positive direction.
    """
    cross = []
    if leftside_prev is None:
        leftside_curr = [orderp < interf for interf in interfaces]
    else:
        leftside_curr = [i for i in leftside_prev]
        for i, (left, interf) in enumerate(zip(leftside_prev, interfaces)):
            if left and orderp > interf:
                leftside_curr[i] = False
                cross.append((cycle, i, '+'))
            elif not left and orderp < interf:
                leftside_curr[i] = True
                cross.append((cycle, i, '-'))
    return leftside_curr, cross


class PathBase(object):
    """PathBase(object) - base class for representation of paths.

    This class represents a path. A path consist of a series of
    consecutive snapshots (the trajectory) with the corresponding order
    parameter. We are going to assume that we always store the order
    parameter as a function of the time. For the other properties, the
    different sub-classes might not store all the intformation.

    Attributes
    ----------
    energy : list of floats
        The energy as a function of time.
    generated : tuple
        This contains information on how the path was generated.
        `generated[0]` : string, as defined in the variable `_GENERATED`
        `generated[1:]` : additional information:
        For ``generated[0] == 'sh'`` the additional information is the
        index of the shooting point on the old path, the new path and
        the corresponding order parameter.
    maxlen : int
        This is the maximum path length. Some algorithms requires this
        to be set. Others don't, which is indicated by setting `maxlen`
        equal to None.
    order : list of floats
        The order parameters as function of time.
    ordermin : tuple
        This is the (current) minimum order parameter for the path.
        `ordermin[0]` is the value, `ordermin[1]` is the index in
        `self.path`.
    ordermax : tuple
        This is the (current) maximum order parameter for the path.
        `ordermax[0]` is the value, `ordermax[1]` is the index in
        `self.path`.
    rgen : object like `RandomGenerator` from `pyretis.core.random_gen`.
        This is the random generator that will be used for the
        paths that required random numbers.
    time_origin : int
        This is the location of the phase point `path[0]` relative to
        its parent. This might be useful for plotting.
    traj : list of numpy.arrays
        `traj[0]` are the positions as function of time.
        `traj[1]` are the velocities as function of time.
    status : str or None
        The status of the path. The possibilities are defined
        in the variable `_STATUS`
    """

    __metaclass__ = ABCMeta

    def __init__(self, rgen, maxlen=None, time_origin=0):
        """Initialize the Path object.

        Parameters
        ----------
        rgen : object like `RandomGenerator` from `pyretis.core.random_gen`.
            This is the random generator that will be used.
        maxlen : int, optional
            This is the max-length of the path. The default value,
            None, is just a path of arbitrary length.
        time_origin : int, optional
            This can be used to store the shooting point of a parent
            trajectory.
        """
        self.order = []
        self.energy = []
        self.traj = []
        self.maxlen = maxlen
        self.length = 0
        self.ordermin = None
        self.ordermax = None
        self.time_origin = time_origin
        self.status = None
        self.generated = None
        self.rgen = rgen

    def _update_orderp(self, orderp, idx):
        """Update current min/max order parameter.

        Update the min/max order parameter given a new order parameter.
        It will just check if the given order parameter is larger or
        smaller than the current ones.

        Parameters
        -----------
        orderp : float
            This is the new order parameter.
        idx : int
            This is the index of the new order parameter in `self.path`.
        """
        if self.ordermax is None or orderp > self.ordermax[0]:
            self.ordermax = (orderp, idx)
        if self.ordermin is None or orderp < self.ordermin[0]:
            self.ordermin = (orderp, idx)

    def get_min_max_orderp(self):
        """Get the minimum and maximum order parameter on the path.

        Update the minimum and maximum order parameter on the path and
        return them. This function will explicitly loop over the path,
        check all phase-space points and find the minimum and maximum
        order parameter. This is useful if the path was read directly
        without calling `append`.

        Returns
        -------
        out[0] : list
            This is the minimum order parameter, tuple with
            (value, index)
        out[1] : list
            This is the maximum order parameter, tuple with
            (value, index)
        """
        ordermin = None
        ordermax = None
        for i in range(self.length):
            orderp = self.order[i][0]
            if ordermin is None or ordermax is None:
                ordermin = (orderp, i)
                ordermax = (orderp, i)
            else:
                if orderp > ordermax[0]:
                    ordermax = (orderp, i)
                if orderp < ordermin[0]:
                    ordermin = (orderp, i)
        self.ordermin = ordermin
        self.ordermax = ordermax
        return ordermin, ordermax

    def check_interfaces(self, interfaces):
        """Check current status of the path.

        Get the current status of the path with respect to the
        `interfaces`. This is intended to determine if we have crossed
        certain interfaces or not.

        Parameters
        ----------
        interfaces : list of floats
            This list is assumed to contain the three interface values
            left, middle and right

        Returns
        -------
        out[0] : str, 'L' or 'R' or None
            Start condition: did the trajectory start at the left ('L')
            or right ('R') interface.
        out[1] : str, 'L' or 'R' or None
            Ending condition: did the trajectory end at the left ('L')
            or right ('R') interface or None of them.
        out[2] str, 'M' or '*'
            'M' if middle interface is crossed, '*' otherwise.
        out[3] : list of boolean
            out[2][i] = True if ordermin < interfaces[i] <= ordermax
        """
        if self.length < 1:
            logger.warning('Path is empty!')
            return None, None, None, None
        ordermax, ordermin = self.ordermax[0], self.ordermin[0]
        cross = [ordermin < interpos <= ordermax for interpos in interfaces]
        left, right = min(interfaces), max(interfaces)
        # check end & start:
        end = self.get_end_point(left, right)
        start = self.get_start_point(left, right)
        middle = 'M' if cross[1] else '*'
        return start, end, middle, cross

    def get_end_point(self, left, right):
        """Return the end point of the path as a string.

        The end point is either to the left of the `left` interface or
        to the right of the `right` interface, or somewhere in between.

        Parameters
        ----------
        left : float
            The left interface
        right : float
            The right interface

        Returns
        -------
        out : string
            String representing where the end point is ('L' - left,
            'R' - right or None).
        """
        if self.order[-1][0] < left:
            end = 'L'
        elif self.order[-1][0] > right:
            end = 'R'
        else:
            end = None
            logger.debug('Undefined end point.')
        return end

    def get_start_point(self, left, right):
        """Return the start point of the path as a string.

        The start point is either to the left of the `left` interface or
        to the right of the `right` interface.

        Parameters
        ----------
        left : float
            The left interface
        right : float
            The right interface

        Returns
        -------
        out : string
            String representing where the start point is ('L' - left,
            'R' - right or None).
        """
        if self.order[0][0] <= left:
            start = 'L'
        elif self.order[0][0] >= right:
            start = 'R'
        else:
            start = None
            logger.debug('Undefined starting point.')
        return start

    @abstractmethod
    def get_shooting_point(self):
        """Return a shooting point from the path.

        Parameters
        ----------
        rgen : object like `RandomGenerator` from `random_gen`.
            This object is used to draw a random integer.

        Returns
        -------
        phasepoint : tuple
            `phasepoint[0]` is the order parameter (as a tuple) and the
            two next items are the positions and velocities.
        idx : int
            The shooting point index.
        """
        return

    @abstractmethod
    def trajectory(self, reverse=False):
        """Iterate over the phase-space points in the path.

        Parameters
        ----------
        reverse : boolean
            If this is True, we iterate in the reverse direction.

        Yields
        ------
        out : tuple
            The phase-space points in the path.
        """
        return

    @abstractmethod
    def phasepoint(self, idx):
        """Return a specific phase point.

        Parameters
        ----------
        idx : int
            Index for phase-space point to return.

        Returns
        -------
        out : tuple
            A phase-space point in the path.
        """
        return

    @abstractmethod
    def append(self, orderp, pos, vel, energy):
        """Append a new phase point to the path.

        Parameters
        ----------
        orderp : list of floats
            This variable is the order parameter for the given point.
            `orderp[0]` is the actual order parameter used in path
            sampling methods while `orderp[1:]` can represent other
            order parameters for instance is `orderp[1]` typically the
            velocity of `orderp[0]`.
        pos : numpy.array
            The positions of the particles,
        vel: numpy.array
            The velocities of the particles.
        energy : dict
            A dict with energy terms for the phase point.
        """
        return

    def get_path_data(self, status, interfaces):
        """Return information about the Path.

        This information can (and is typically) stored in a
        `PathEnsemble`.

        Parameters
        ----------
        status : string
            This represents the current status of the path.
        interfaces : list
            These are just the interfaces we are currently considering.
        """
        path_info = {'generated': self.generated,
                     'status': status,
                     'length': self.length}

        path_info['ordermax'] = tuple(self.ordermax)
        path_info['ordermin'] = tuple(self.ordermin)

        start, end, middle, _ = self.check_interfaces(interfaces)
        path_info['interface'] = (start, middle, end)
        return path_info

    def set_move(self, move):
        """Update the path move.

        The path move is a short string that represent how the path
        was generated. It should preferably match one of the moves
        defined in `_GENERATED`

        Parameters
        ----------
        move : string
            A short description of the move
        """
        if self.generated is None:
            self.generated = (move, 0, 0, 0)
        else:
            self.generated = (move, self.generated[1], self.generated[2],
                              self.generated[3])

    def success(self, detect):
        """Check if the path is successful.

        The check is based on the maximum order parameter and the value
        of `detect`. It is successful if the maximum order parameter is
        greater than `detect`.

        Parameters
        ----------
        detect : float
            The value for which the path is successful, i.e. the
            "detect" interface.
        """
        return self.ordermax[0] > detect

    def __iadd__(self, other):
        """Add path data to a path from another path, i.e. ``self += other``.

        This will simply append the phase points from `other`.

        Parameters
        ----------
        other : object of type `Path`
            The object to add path data from.

        Returns
        -------
        self : object of type `Path`
            The updated path object.
        """
        for phasepoint in other.trajectory():
            app = self.append(*phasepoint)
            if not app:
                msg = 'Truncated path while +=: {}'.format(self.length)
                logger.warning(msg)
                return self
        return self

    def reverse(self):
        """Reverse a path and return the reverse path as a new path.

        This will simply reverse a path and return the reversed path as
        a new `Path` object. Note that currently, recalculating
        order parameters have not been implemented!  Typically, reversing
        will not change the order parameter, but it might change the
        velocity for the order parameter and so on.

        Returns
        -------
        new_path : object like `PathBase`
            This is basically a copy of `self`, just reversed.
        """
        new_path = self.empty_path()
        for phasepoint in self.trajectory(reverse=True):
            pos = phasepoint[1]
            energy = phasepoint[3]
            if phasepoint[2] is not None:
                vel = phasepoint[2] * -1
            else:
                vel = phasepoint[2]
            orderp = phasepoint[0]
            app = new_path.append(orderp, pos, vel, energy)
            if not app:
                msg = 'Could not reverse path'
                logger.error(msg)
                return None
        return new_path

    def __str__(self):
        """Return a simple string representation of the Path."""
        msg = ['Path with length {} (max: {})'.format(self.length,
                                                      self.maxlen)]
        msg += ['Order parameter max: {}'.format(self.ordermax)]
        msg += ['Order parameter min: {}'.format(self.ordermin)]
        if self.length > 0:
            msg += ['Start {}'.format(self.order[0][0])]
            msg += ['End {}'.format(self.order[-1][0])]
        if self.status:
            msg += ['Status: {}'.format(_STATUS[self.status])]
        if self.generated:
            msg += ['Generated: {}'.format(_GENERATED[self.generated[0]])]
        return '\n'.join(msg)

    @abstractmethod
    def empty_path(self, **kwargs):
        """Return an empty path of same class as the current one.

        This function is intended to spawn child paths that share some
        propertis and also some characteristics of the current path.
        The idea here is that a path of a certain class should only be
        able to create paths of the same class.

        Returns
        -------
        out : object like `PathBase`.
            A new empty path.
        """
        return


class Path(PathBase):
    """Path(PathBase) - representation of paths.

    This class represents a path. A path consist of a series of
    consecutive snapshots (the trajectory) with the corresponding
    order parameter. Here we store all information for all phase points
    on the path.
    """

    def __init__(self, rgen, maxlen=None, time_origin=0):
        """Initialize the Path object.

        Parameters
        ----------
        rgen : object like `RandomGenerator` from `pyretis.core.random_gen`
            This is the random generator that will be used.
        maxlen : int, optional
            This is the max-length of the path. The default value,
            None, is just a path of arbitrary length.
        time_origin : int, optional
            This can be used to store the shooting point of a parent
            trajectory.
        """
        super(Path, self).__init__(rgen, maxlen=maxlen,
                                   time_origin=time_origin)

    def trajectory(self, reverse=False):
        """Iterate over the phase-space points in the path.

        Parameters
        ----------
        reverse : boolean
            If this is True, we iterate in the reverse direction.

        Yields
        ------
        out : tuple
            The phase-space points in the path.
        """
        if reverse:
            for i in range(self.length - 1, -1, -1):
                yield (self.order[i], self.traj[i][0], self.traj[i][1],
                       self.energy[i])
        else:
            for i in range(self.length):
                yield (self.order[i], self.traj[i][0], self.traj[i][1],
                       self.energy[i])

    def phasepoint(self, idx):
        """Return a specific phase point.

        Parameters
        ----------
        idx : int
            Index for phase-space point to return.

        Returns
        -------
        out : tuple
            A phase-space point in the path.
        """
        return (self.order[idx], self.traj[idx][0], self.traj[idx][1],
                self.energy[idx])

    def append(self, orderp, pos, vel, energy):
        """Append a new phase point to the path.

        We will here append a new phase-space point to the path.
        The phase point is assumed to be given by positions and
        velocities with a corresponding order parameter and energy.

        Parameters
        ----------
        orderp : list of floats
            This variable is the order parameter for the given point.
            `orderp[0]` is the actual order parameter used in path
            sampling methods while `orderp[1:]` can represent other
            order parameters for instance is `orderp[1]` typically the
            velocity of `orderp[0]`.
        pos : numpy.array
            The positions of the particles,
        vel: numpy.array
            The velocities of the particles.
        energy : dict
            A dict with energy terms for the phase point.
        """
        if self.maxlen is None or self.length < self.maxlen:
            self.order.append(orderp)
            self._update_orderp(orderp[0], self.length)
            self.energy.append(energy)
            self.traj.append([np.copy(pos), np.copy(vel)])
            self.length += 1
            return True
        else:
            msg = 'Max length exceeded! Could not append to path!'
            logger.debug(msg)
            return False

    def get_shooting_point(self):
        """Return a shooting point from the path.

        This will simply draw a shooting point from the path at
        random. All points can be selected with equal probability with
        the exception of the end points which are not considered.

        Returns
        -------
        phasepoint : tuple
            `phasepoint[0]` is the order parameter (as a tuple) and the
            two next items are the positions and velocities.
        idx : int
            The shooting point index.
        """
        idx = self.rgen.random_integers(1, self.length - 2)
        return self.order[idx], self.traj[idx][0], self.traj[idx][1], idx

    def empty_path(self, **kwargs):
        """Return an empty path of same class as the current one.

        Returns
        -------
        out : object like `PathBase`.
            A new empty path.
        """
        maxlen = kwargs.get('maxlen', self.maxlen)
        time_origin = kwargs.get('time_origin', self.time_origin)
        return self.__class__(self.rgen, maxlen=maxlen,
                              time_origin=time_origin)


class ReservoirPath(PathBase):
    """ReservoirPath(PathBase) - representation of paths.

    This class represents a path. A path consist of a series of
    consecutive snapshots (the trajectory) with the corresponding order
    parameter. Here we store phase points for only a small subset of the
    points in the path and maintain a reservoir of shooting points that
    are picked with the correct probability.
    """

    def __init__(self, rgen, maxlen=None, time_origin=0, res_length=10):
        """Initialize the Path object.

        Parameters
        ----------
        rgen : object like `RandomGenerator` from `pyretis.core.random_gen`.
            This is the random generator that will be used.
        maxlen : int, optional
            This is the max-length of the path. The default value,
            None, is just a path of arbitrary length.
        time_origin : int, optional
            This can be used to store the shooting point of a parent
            trajectory.
        res_length : int, optional
            This is the number of shooting-point candidates to store.
        """
        super(ReservoirPath, self).__init__(rgen, maxlen=maxlen,
                                            time_origin=time_origin)
        self.res_length = res_length
        self.reservoir = []

    def trajectory(self, reverse=False):
        """Iterate over the phase-space points in the path.

        Parameters
        ----------
        reverse : boolean
            If this is True, we iterate in the reverse direction.

        Yields
        ------
        out : tuple
            The phase-space points in the path.
        """
        if reverse:
            for i in range(self.length - 1, -1, -1):
                yield self.order[i], None, None, self.energy[i]
        else:
            for i in range(self.length):
                yield self.order[i], None, None, self.energy[i]

    def phasepoint(self, idx):
        """Return a specific phase point.

        Parameters
        ----------
        idx : int
            Index for phase-space point to return.

        Returns
        -------
        out : tuple
            A phase-space point in the path.
        """
        return self.order[idx], None, None, self.energy[idx]

    def append(self, orderp, pos, vel, energy):
        """Append a new phase point to the path.

        We will here append a new phase-space point to the path.
        The phase point is assumed to be given by positions and
        velocities with a corresponding order parameter and energy.

        Parameters
        ----------
        orderp : list of floats
            This variable is the order parameter for the given point.
            `orderp[0]` is the actual order parameter used in path
            sampling methods while `orderp[1:]` can represent other
            order parameters for instance is `orderp[1]` typically the
            velocity of `orderp[0]`.
        pos : numpy.array
            The positions of the particles,
        vel: numpy.array
            The velocities of the particles.
        energy : dict
            A dict with energy terms for the phase point.
        """
        if self.maxlen is None or self.length < self.maxlen:
            self.order.append(orderp)
            self._update_orderp(orderp[0], self.length)
            self.energy.append(energy)
            if pos is not None and vel is not None:
                self.add_to_reservoir(self.length + 1, self.length, pos, vel)
            self.length += 1
            return True
        else:
            msg = 'Path length exceeded! Could not append to path!'
            logger.debug(msg)
            return False

    def get_shooting_point(self):
        """Return a shooting point from the path.

        This will simply draw a shooting point from the path at
        random. All points can be selected with equal probability with
        the exception of the end points which are not considered.

        Parameters
        ----------

        Returns
        -------
        phasepoint : tuple
            `phasepoint[0]` is the order parameter (as a tuple) and the
            two next items are the positions and velocities.
        idx : int
            The shooting point index.
        """
        if len(self.reservoir) < 1:
            logger.critical('Reservoir empty, need to regenerate path!')
            return None
        else:
            item = self.reservoir.pop()
            idx = item[0]
            return self.order[idx], item[1], item[2], idx

    def add_to_reservoir(self, items, idx, pos, vel):
        """Try to add a point to the reservoir.

        Parameters
        ----------
        items : int
            The number of items seen by the reservoir.
        idx : int
            This is the index along the path for the `pos` and `vel`.
        pos : numpy.array
            The positions to store.
        vel : numpy.array
            The velocities to store.
        """
        if items == 1:
            for i in range(self.res_length):
                self.reservoir.append((idx, np.copy(pos), np.copy(vel)))
        else:
            factor = 1.0 / float(items)
            for i in range(self.res_length):
                if self.rgen.rand() < factor:
                    self.reservoir[i] = (idx, np.copy(pos), np.copy(vel))

    def empty_path(self, **kwargs):
        """Return an empty path of same class as the current one.

        For this empty path, the reservoir is not populated.

        Returns
        -------
        out : object like `PathBase`.
            A new empty path.
        """
        maxlen = kwargs.get('maxlen', self.maxlen)
        time_origin = kwargs.get('time_origin', self.time_origin)
        res_length = kwargs.get('res_length', self.res_length)
        return self.__class__(self.rgen, maxlen=maxlen,
                              time_origin=time_origin,
                              res_length=res_length)

    def reverse(self):
        """Reverse the path with addinional handling for the reservoir.

        This method will call `PathBase.reverse()` but will also do
        some extra reverse handling since we here have to reverse
        indices in the reservoir of shooting points.

        Returns
        -------
        path : object like `PathBase`.
            This is basically a copy of `self`, just reversed.
        """
        path = super(ReservoirPath, self).reverse()
        path.reservoir = []
        for point in self.reservoir:
            idx = self.length - 1 - point[0]
            path.reservoir.append((idx, np.copy(point[1]), np.copy(point[2])))
        return path


class PathExternal(PathBase):
    """PathExternal(PathBase) - representation of paths.

    This class represents a path, however in this case we do not load all
    positions and velocities into the path object. We only store the order
    parameters and possibly energies while the positions and velocities
    are to be loaded from files.
    """

    def __init__(self, rgen, maxlen=None, time_origin=0):
        """Initialize the Path object.

        Parameters
        ----------
        rgen : object like `RandomGenerator` from `pyretis.core.random_gen`
            This is the random generator that will be used.
        maxlen : int, optional
            This is the max-length of the path. The default value,
            None, is just a path of arbitrary length.
        time_origin : int, optional
            This can be used to store the shooting point of a parent
            trajectory.
        """
        super(PathExternal, self).__init__(rgen, maxlen=maxlen,
                                           time_origin=time_origin)

    def trajectory(self, reverse=False):
        """Iterate over the phase-space points in the path.

        Parameters
        ----------
        reverse : boolean
            If this is True, we iterate in the reverse direction.

        Yields
        ------
        out : tuple
            The phase-space points in the path.
        """
        if reverse:
            for i in range(self.length - 1, -1, -1):
                yield (self.order[i], None, None, self.energy[i])
        else:
            for i in range(self.length):
                yield (self.order[i], None, None, self.energy[i])

    def phasepoint(self, idx):
        """Return a specific phase point.

        Parameters
        ----------
        idx : int
            Index for phase-space point to return.

        Returns
        -------
        out : tuple
            A phase-space point in the path.
        """
        return (self.order[idx], self.traj[idx][0], self.traj[idx][1],
                self.energy[idx])

    def append(self, orderp, pos, vel, energy):
        """Append a new phase point to the path.

        We will here append a new phase-space point to the path.
        The phase point is assumed to be given by positions and
        velocities with a corresponding order parameter and energy.

        Parameters
        ----------
        orderp : list of floats
            This variable is the order parameter for the given point.
            `orderp[0]` is the actual order parameter used in path
            sampling methods while `orderp[1:]` can represent other
            order parameters for instance is `orderp[1]` typically the
            velocity of `orderp[0]`.
        pos : numpy.array
            The positions of the particles,
        vel: numpy.array
            The velocities of the particles.
        energy : dict
            A dict with energy terms for the phase point.
        """
        if self.maxlen is None or self.length < self.maxlen:
            self.order.append(orderp)
            self._update_orderp(orderp[0], self.length)
            self.energy.append(energy)
            self.traj.append([np.copy(pos), np.copy(vel)])
            self.length += 1
            return True
        else:
            msg = 'Max length exceeded! Could not append to path!'
            logger.debug(msg)
            return False

    def get_shooting_point(self):
        """Return a shooting point from the path.

        This will simply draw a shooting point from the path at
        random. All points can be selected with equal probability with
        the exception of the end points which are not considered.

        Returns
        -------
        phasepoint : tuple
            `phasepoint[0]` is the order parameter (as a tuple) and the
            two next items are the positions and velocities.
        idx : int
            The shooting point index.
        """
        idx = self.rgen.random_integers(1, self.length - 2)
        return self.order[idx], self.traj[idx][0], self.traj[idx][1], idx

    def empty_path(self, **kwargs):
        """Return an empty path of same class as the current one.

        Returns
        -------
        out : object like `PathBase`.
            A new empty path.
        """
        maxlen = kwargs.get('maxlen', self.maxlen)
        time_origin = kwargs.get('time_origin', self.time_origin)
        return self.__class__(self.rgen, maxlen=maxlen,
                              time_origin=time_origin)
