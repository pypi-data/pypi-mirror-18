# -*- coding: utf-8 -*-
# Copyright (c) 2015, pyretis Development Team.
# Distributed under the LGPLv3 License. See LICENSE for more info.
"""Classes and functions for path ensembles.

The classes and functions defined in this module are useful for
representing path ensembles.

Important classes defined here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PathEnsemble
    Class for defining path ensembles.

Important methods defined here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

create_path_ensembles
    Method for creating a set of `PathEnsemble` objects from given
    interfaces.
"""
import logging
logger = logging.getLogger(__name__)  # pylint: disable=C0103
logger.addHandler(logging.NullHandler())


__all__ = ['PathEnsemble', 'create_path_ensembles']


PATH_DIR_FMT = '{:03d}'  # For naming path ensemble (and its output dir).


class PathEnsemble(object):
    """PathEnsemble(object) - representation of a path ensemble.

    This class represents a collection of `Paths` in a path ensemble.
    In general paths may be 'long and complicated' so here, we really
    just store an simplified abstraction of the path, which is obtained
    by the `Path.get_path_data()` function for a given `Path` object.
    The returned dictionary is stored in the list `PathEnsemble.paths`.
    The only path we store, is the last accepted path. This is
    convenient for the RETIS method where paths may be swapped between
    path ensembles.

    Attributes
    ----------
    ensemble : integer
        This integer is used to represent the path ensemble, for retis
        simulations it's useful to identify the path ensemble. The path
        ensembles are numbered sequentially 0, 1, 2, etc. This
        corresponds to ``[0^-]``, ``[0^+]``, ``[1^+]``, etc.
    ensemble_name : string
        A string which can be used for printing the ensemble name
    ensemble_name_simple : string
        A string with a simpler representation of the ensemble name,
        can be used for creating output files etc.
    interfaces : list of floats
        Interfaces, specified with the values for the
        order parameters: `[left, middle, right]`.
    detect : float
        Interface to use for analysis.
    paths : list
        This list contains the stored information for the paths. Here
        we only store the data returned by calling the `get_path_data()`
        function of the `Path` object.
    nstats : dict of ints
        This dict store some statistics for the path ensemble. The keys
        are:

        - `npath` : The number of paths stored.
        - `nshoot` : The number of accepted paths generated by shooting.
        - `ACC`, `BWI`, ... : Number of paths with given status
          (from `_STATUS`).
    maxpath : int
        The maximum number of paths to store.
    last_path : object like `pyretis.core.Path`
        This is the last **accepted** path.
    """

    def __init__(self, ensemble, interfaces, detect=None, maxpath=100):
        """Initialize the PathEnsemble object.

        Parameters
        ----------
        ensemble : integer
            An integer used to identify the ensemble.
        interfaces : list of floats
            These are the interfaces specified with the values
            for the order parameters: [left, middle, right]
        """
        self.ensemble = ensemble
        self.interfaces = tuple(interfaces)  # Should not change interfaces
        self.detect = detect  # detect interface to use for analysis
        self.last_path = None
        self.nstats = {'npath': 0, 'nshoot': 0, 'ACC': 0}
        self.paths = []
        self.maxpath = maxpath
        if self.ensemble == 0:
            self.ensemble_name = '[0^-]'
        else:
            self.ensemble_name = '[{}^+]'.format(self.ensemble - 1)
        self.ensemble_name_simple = PATH_DIR_FMT.format(self.ensemble)

    def reset_data(self):
        """Erase the stored data in the path ensemble.

        It can be used in combination with flushing the data to a
        file in order to periodically write and empty the amount of data
        stored in memory.

        Notes
        -----
        We do not reset `self.last_path` as this might be used in the
        RETIS function.
        """
        self.paths = []
        for key in self.nstats:
            self.nstats[key] = 0

    def add_path_data(self, path, status, cycle=0):
        """Append data from the given path to `self.path_data`.

        This will add the data from a given` path` to the list path data
        for this ensemble. If will also update `self.last_path` if the
        given `path` is accepted.

        Parameters
        ----------
        path : object like `Path`
            This is the object to store data from.
        status : string
            This is the status of the path. Note that the path object
            also have a status property. However this one might not be
            set, for instance when path is just None. We therefore use
            `status` here as a parameter.
        cycle : int, optional
            The current cycle number
        """
        if len(self.paths) >= self.maxpath:
            msg = ('Exceeded maximum number of paths in ensemble {}!\n'
                   'The path-data in this path ensemble will be reset.\n'
                   'Note that this will *NOT* influence the simulation. '
                   'Remember to use the path ensemble file for an '
                   'accurate analysis!')
            msg = msg.format(self.ensemble_name)
            logger.info(msg)
            self.paths = []
        # update statistics:
        if path is None:
            # Here we add a dummy path with minimal info. This is because we
            # could not generate a path for some reason which should be
            # specified by the status.
            path_data = {'status': status, 'generated': ('', 0, 0, 0)}
        else:
            path_data = path.get_path_data(status, self.interfaces)
            if path_data['status'] == 'ACC':  # store the path
                self.last_path = path
                if path_data['generated'][0] == 'sh':
                    self.nstats['nshoot'] += 1
        path_data['cycle'] = cycle  # also store cycle number
        self.paths.append(path_data)  # store the new data
        # update some statistics:
        try:
            self.nstats[status] += 1
        except KeyError:  # this is the first occurrence of the status:
            self.nstats[status] = 1
        self.nstats['npath'] += 1

    def get_accepted(self):
        """Yield accepted paths from the PathEnsemble.

        This function  will give an iterator useful for iterating over
        accepted paths only. In the PathEnsemble we store both accepted
        and rejected paths. This function will loop over all paths
        stored and yield the accepted paths the correct number of times.
        """
        last_path = None
        for path in self.paths:
            if path['status'] == 'ACC':
                last_path = path
            yield last_path

    def get_acceptance_rate(self):
        """Return acceptance rate for the path ensemble.

        The acceptance rate is obtained as the fraction of accepted
        paths to the total number of paths in the path ensemble. This
        will only consider the paths that are currently stored in
        `self.paths`.

        Returns
        -------
        out : float
            The acceptance rate.
        """
        acc = 0
        npath = 0
        for path in self.paths:
            if path['status'] == 'ACC':
                acc += 1
            npath += 1
        return float(acc) / float(npath)

    def get_paths(self):
        """Yield the different paths stored in the path ensemble.

        It is included here in order to have a simple compatibility
        between the `PathEnsemble` object and the `PathEnsembleFile`
        object defined in `pyretis.inout`. This is useful for the
        analysis.

        Yields
        ------
        out : dict
            This is the dictionary representing the path data.
        """
        for path in self.paths:
            yield path

    def get_start_condition(self):
        """Return the appropriate start condition for an ensemble.

        This is useful for RETIS simulations where we for ``[0^-]``
        (that is ``self.ensemble == 0``)  will have the start condition
        equal to 'R'ight. For all other ensembles we assume that we
        start from the 'L'eft.

        Returns
        -------
        out : string
            'R' for right or 'L' for left start condition.
        """
        if self.ensemble == 0:
            return 'R'
        else:
            return 'L'

    def __str__(self):
        """Return a string with some info about the path ensemble."""
        msg = ['Path ensemble: {}'.format(self.ensemble_name)]
        msg += ['\tInterfaces: {}'.format(self.interfaces)]
        if self.detect is not None:
            msg += ['\tDetect: {}'.format(self.detect)]
        if self.nstats['npath'] > 0:
            npath = self.nstats['npath']
            nacc = self.nstats.get('ACC', 0)
            msg += ['\tNumber of paths stored: {}'.format(npath)]
            msg += ['\tNumber of accepted paths: {}'.format(nacc)]
            ratio = float(nacc) / float(npath)
            msg += ['\tRatio accepted/total paths: {}'.format(ratio)]
        return '\n'.join(msg)


def create_path_ensembles(interfaces, include_zero=False):
    """Create a list of `PathEnsemble` objects given a list of interfaces.

    This function will create and return a set of objects representing
    path ensembles for a given set of interfaces. This is useful when
    setting up simulations like RETIS. Here we assume that the given
    interfaces define the path ensembles as follows:
    ``[0^-] | [0^+] | [1^+] | ... | [(n-1)^+] | state B``, where ``|``
    is the specified interface locations in the input `interfaces`.
    We assume that the reactant is to the left of `interfaces[0]` and
    that the product is to the right of `interfaces[-1]`. Given ``n``
    interfaces we generate ``n`` or ``n-1`` path ensembles, the former
    if we include the [0^-] ensemble.

    Parameters
    ----------
    interfaces : list of floats
        `interfaces[i]` separates the [(i-1)^+] and [i^+] interfaces.
    include_zero : boolean
        If `include_zero` is True, we include path ensemble [0^-].

    Returns
    -------
    ensembles : list of objects like `PathEnsemble`.
        The generated (empty) path ensemble objects.
    detect : list of floats
        These are interfaces that can be used for an analysis, i.e. for
        detection and matching of probabilities.
    """
    detect = []
    ensembles = []
    reactant = interfaces[0]
    product = interfaces[-1]
    if include_zero:
        interface = [-float('inf'), reactant, reactant]
        path_ensemble = PathEnsemble(0, interface, detect=None)
        ensembles.append(path_ensemble)
    for i, middle in enumerate(interfaces[:-1]):
        interface = [reactant, middle, product]
        try:
            detect.append(interfaces[i+1])
        except IndexError:
            detect.append(product)
        path_ensemble = PathEnsemble(i + 1, interface, detect=detect[-1])
        ensembles.append(path_ensemble)
    return ensembles, detect
