"""Scaffold supporting files and directories."""
from __future__ import absolute_import

import datetime
import io
import pathlib

import fasteners.process_lock

import reqwire.config
import reqwire.errors
import reqwire.helpers.requirements


MYPY = False
if MYPY:
    from typing import (  # noqa: F401
        Iterable,
        Iterator,
        Optional,
        Set,
        Type,
    )


__all__ = (
    'init_source_dir',
    'init_source_file',
)


DEFAULT_HEADER = """\
# Generated by reqwire on %c
{index_url}{extra_index_urls}
"""


def build_filename(working_directory,  # type: str
                   tag_name,           # type: str
                   extension='.in',    # type: str
                   prefix='src',       # type: str
                   ):
    # type: (...) -> pathlib.Path
    wd = pathlib.Path(working_directory) / prefix
    return wd / ''.join((tag_name, extension))


def build_source_header(format_string=DEFAULT_HEADER,  # type: str
                        index_url=None,                # type: Optional[str]
                        extra_index_urls=None,  # type: Optional[Iterable[str]]
                        timestamp=None,  # type: Optional[datetime.datetime]
                        ):
    # type: (...) -> str
    if timestamp is None:
        timestamp = datetime.datetime.now()
    if index_url is not None:
        index_url_text = ' '.join(('--index-url', index_url.strip()))
    else:
        index_url_text = ''
    if extra_index_urls is not None:
        extra_index_urls_text = '\n'.join(
            ' '.join(('--extra-index-url', extra_index_url))
            for extra_index_url in extra_index_urls)
    else:
        extra_index_urls_text = ''
    return timestamp.strftime(format_string).format(
        index_url=index_url_text,
        extra_index_urls=extra_index_urls_text)


@fasteners.process_lock.interprocess_locked(str(reqwire.config.lockfile))
def extend_source_file(working_directory,             # type: str
                       tag_name,                      # type: str
                       specifiers,                    # type: Iterable[str]
                       extension='.in',               # type: str
                       index_url=None,                # type: Optional[str]
                       extra_index_urls=None,   # type: Optional[Iterable[str]]
                       lookup_index_urls=None,  # type: Optional[Iterable[str]]
                       resolve_canonical_names=True,  # type: bool
                       resolve_versions=True,         # type: bool
                       ):
    # type: (...) -> None
    if extra_index_urls is None:
        extra_index_urls = set()
    else:
        extra_index_urls = set(extra_index_urls)

    filename = build_filename(
        working_directory=working_directory,
        tag_name=tag_name,
        extension=extension)

    if filename.exists():
        requirements, finder = reqwire.helpers.requirements.parse_requirements(
            filename=str(filename))
        if finder.index_urls:
            if index_url is not None and index_url != finder.index_urls[0]:
                raise reqwire.errors.IndexUrlMismatchError(
                    '"{}" != "{}"'.format(index_url, finder.index_urls[0]))
            elif index_url is None:
                index_url = finder.index_urls[0]

            if len(finder.index_urls) > 1:
                extra_index_urls |= set(finder.index_urls[1:])
    else:
        requirements = set()
        finder = None

    if lookup_index_urls is None:
        lookup_index_urls = {index_url} if index_url is not None else set()
        if extra_index_urls is not None:
            lookup_index_urls |= set(extra_index_urls)

        if not lookup_index_urls and finder is not None and finder.index_urls:
            lookup_index_urls.add(finder.index_urls[0])
            if len(finder.index_urls) > 1:
                lookup_index_urls |= set(finder.index_urls[1:])

    requirements |= reqwire.helpers.requirements.build_ireq_set(
        specifiers=specifiers,
        index_urls=lookup_index_urls,
        resolve_canonical_names=resolve_canonical_names,
        resolve_versions=resolve_versions)

    resolved_requirements = reqwire.helpers.requirements.resolve_ireqs(
        requirements=requirements, intersect=True)

    reqwire.helpers.requirements.write_requirements(
        filename=str(filename),
        requirements=resolved_requirements,
        header=build_source_header(
            index_url=index_url,
            extra_index_urls=extra_index_urls))


def init_source_dir(working_directory,    # type: str
                    mode=0o777,           # type: int
                    create_parents=True,  # type: bool
                    exist_ok=False,       # type: bool
                    name='src',           # type: str
                    ):
    # type: (...) -> pathlib.Path
    """Creates a requirements source directory."""
    wd = pathlib.Path(working_directory)
    src = wd / name
    try:
        src.mkdir(mode=mode, parents=create_parents)
    except OSError:
        if not exist_ok:
            raise
    return src


def init_source_file(working_directory,      # type: str
                     tag_name,               # type: str
                     extension='.in',        # type: str
                     index_url=None,         # type: Optional[str]
                     extra_index_urls=None,  # type: Optional[Iterable[str]]
                     encoding=None,          # type: Optional[str]
                     errors=None,            # type: Optional[str]
                     mode=0o666,             # type: int
                     overwrite=False,        # type: bool
                     ):
    # type: (...) -> pathlib.Path
    """Creates a requirements source file.

    Args:
        working_directory: The requirements working directory.
        tag_name: The tag name.
        extension: The file extension. Defaults to ".in".
        index_url: Base URL of Python package index.
        extra_index_urls: Iterable of URLs of secondary package indexes.
        encoding: Passed to :func:`io.open` when creating source file.
        errors: Passed to :func:`io.open` when creating source file.
        mode: Permissions with which to create source file. Defaults to
            `0666`.
        overwrite: Whether or not to overwrite an existing source file.

    Returns:
        Path to source file.

    """
    filename = build_filename(
        working_directory=working_directory,
        tag_name=tag_name,
        extension=extension)
    try:
        filename.touch(mode=mode)
    except OSError:
        if not overwrite:
            raise

    with io.open(str(filename), 'wb', encoding=encoding, errors=errors) as f:
        f.write(build_source_header())

    return filename
