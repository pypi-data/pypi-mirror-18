
Gory doctest that shouldn't be in docs
======================================

To show this,
we'll use a contrived example:

.. doctest::

    >>> ntry = 0
    >>> with transaction.manager:
    ...      dm['ntry'] = 0

    >>> import transaction.interfaces
    >>> class Retry(transaction.interfaces.TransientError):
    ...     pass

    >>> for attempt in transaction.manager.attempts():
    ...     with attempt as t:
    ...         t.note('test')
    ...         print("%s %s" % (dm['ntry'], ntry))
    ...         ntry += 1
    ...         dm['ntry'] = ntry
    ...         if ntry % 3:
    ...             raise Retry(ntry)
    0 0
    0 1
    0 28

The raising of a subclass of TransientError is critical here. It's
what signals that the transaction should be retried.  It is generally
up to the data manager to signal that a transaction should try again
by raising a subclass of TransientError (or TransientError itself, of
course).

You shouldn't make any assumptions about the object returned by the
iterator.  (It isn't a transaction or transaction manager, as far as
you know. :)  If you use the ``as`` keyword in the ``with`` statement,
a transaction object will be assigned to the variable named.

By default, it tries 3 times. We can tell it how many times to try:

.. doctest::

    >>> for attempt in transaction.manager.attempts(2):
    ...     with attempt:
    ...         ntry += 1
    ...         if ntry % 3:
    ...             raise Retry(ntry)
    Traceback (most recent call last):
    ...
    Retry: 5

It it doesn't succeed in that many times, the exception will be
propagated.

Of course, other errors are propagated directly:

.. doctest::

    >>> ntry = 0
    >>> for attempt in transaction.manager.attempts():
    ...     with attempt:
    ...         ntry += 1
    ...         if ntry % 3:
    ...             raise ValueError(ntry)
    Traceback (most recent call last):
    ...
    ValueError: 3

We can use the default transaction manager:

.. doctest::

    >>> ntry = 0
    >>> for attempt in transaction.attempts():
    ...     with attempt as t:
    ...         t.note('test')
    ...         print("%s %s" % (dm['ntry'], ntry))
    ...         ntry += 1
    ...         dm['ntry'] = ntry
    ...         if ntry % 3:
    ...             raise Retry(ntry)
    3 0
    3 1
    3 2

Sometimes, a data manager doesn't raise exceptions directly, but
wraps other other systems that raise exceptions outside of it's
control.  Data  managers can provide a should_retry method that takes
an exception instance and returns True if the transaction should be
attempted again.

.. doctest::

    >>> class DM(transaction.tests.savepointsample.SampleSavepointDataManager):
    ...     def should_retry(self, e):
    ...         if 'should retry' in str(e):
    ...             return True

    >>> ntry = 0
    >>> dm2 = DM()
    >>> with transaction.manager:
    ...     dm2['ntry'] = 0
    >>> for attempt in transaction.manager.attempts():
    ...     with attempt:
    ...         print("%s %s" % (dm['ntry'], ntry))
    ...         ntry += 1
    ...         dm['ntry'] = ntry
    ...         dm2['ntry'] = ntry
    ...         if ntry % 3:
    ...             raise ValueError('we really should retry this')
    3 0
    3 1
    3 2

    >>> dm2['ntry']
    3
